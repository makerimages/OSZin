
obj/Elf.o:     file format elf32-i386


Disassembly of section .text:

00000000 <_Z8elf_initP34multiboot_elf_section_header_table>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	55                   	push   %ebp
   1:	57                   	push   %edi
   2:	56                   	push   %esi
   3:	53                   	push   %ebx
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	31 f6                	xor    %esi,%esi
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   6:	83 ec 1c             	sub    $0x1c,%esp
   9:	8b 7c 24 30          	mov    0x30(%esp),%edi
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
   d:	8b 47 0c             	mov    0xc(%edi),%eax
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);
  10:	8b 5f 08             	mov    0x8(%edi),%ebx

	uint32_t shstrtab = sh[header->shndx].addr;
  13:	8d 04 80             	lea    (%eax,%eax,4),%eax
  16:	8b 44 c3 0c          	mov    0xc(%ebx,%eax,8),%eax
  1a:	83 c3 0c             	add    $0xc,%ebx
  1d:	89 44 24 0c          	mov    %eax,0xc(%esp)

	for(uint32_t i = 0; i < header->num; i++) {
  21:	8b 07                	mov    (%edi),%eax
  23:	85 c0                	test   %eax,%eax
  25:	75 22                	jne    49 <_Z8elf_initP34multiboot_elf_section_header_table+0x49>
  27:	eb 77                	jmp    a0 <_Z8elf_initP34multiboot_elf_section_header_table+0xa0>
  29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
  30:	8b 03                	mov    (%ebx),%eax
  32:	a3 08 00 00 00       	mov    %eax,0x8
			elf.strtabsz = sh[i].size;
  37:	8b 43 08             	mov    0x8(%ebx),%eax
  3a:	a3 0c 00 00 00       	mov    %eax,0xc
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  3f:	83 c6 01             	add    $0x1,%esi
  42:	83 c3 28             	add    $0x28,%ebx
  45:	39 37                	cmp    %esi,(%edi)
  47:	76 57                	jbe    a0 <_Z8elf_initP34multiboot_elf_section_header_table+0xa0>
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
  49:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  4d:	03 6b f4             	add    -0xc(%ebx),%ebp
		if(!strcmp(name,".strtab")) {
  50:	83 ec 08             	sub    $0x8,%esp
  53:	68 00 00 00 00       	push   $0x0
  58:	55                   	push   %ebp
  59:	e8 fc ff ff ff       	call   5a <_Z8elf_initP34multiboot_elf_section_header_table+0x5a>
  5e:	83 c4 10             	add    $0x10,%esp
  61:	85 c0                	test   %eax,%eax
  63:	74 cb                	je     30 <_Z8elf_initP34multiboot_elf_section_header_table+0x30>
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
  65:	83 ec 08             	sub    $0x8,%esp
  68:	68 08 00 00 00       	push   $0x8
  6d:	55                   	push   %ebp
  6e:	e8 fc ff ff ff       	call   6f <_Z8elf_initP34multiboot_elf_section_header_table+0x6f>
  73:	83 c4 10             	add    $0x10,%esp
  76:	85 c0                	test   %eax,%eax
  78:	75 c5                	jne    3f <_Z8elf_initP34multiboot_elf_section_header_table+0x3f>
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  7a:	8b 03                	mov    (%ebx),%eax
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  7c:	83 c6 01             	add    $0x1,%esi
  7f:	83 c3 28             	add    $0x28,%ebx
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  82:	a3 00 00 00 00       	mov    %eax,0x0
			elf.symtabsz = sh[i].size;
  87:	8b 43 e0             	mov    -0x20(%ebx),%eax
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  8a:	39 37                	cmp    %esi,(%edi)
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
  8c:	a3 04 00 00 00       	mov    %eax,0x4
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  91:	77 b6                	ja     49 <_Z8elf_initP34multiboot_elf_section_header_table+0x49>
  93:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
		}
	}
}
  a0:	83 c4 1c             	add    $0x1c,%esp
  a3:	5b                   	pop    %ebx
  a4:	5e                   	pop    %esi
  a5:	5f                   	pop    %edi
  a6:	5d                   	pop    %ebp
  a7:	c3                   	ret    
  a8:	90                   	nop
  a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000000b0 <_Z16elf_lookupSymbolm>:

const char* elf_lookupSymbol(uint32_t addr) {
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  b0:	8b 0d 04 00 00 00    	mov    0x4,%ecx
			elf.symtabsz = sh[i].size;
		}
	}
}

const char* elf_lookupSymbol(uint32_t addr) {
  b6:	53                   	push   %ebx
  b7:	8b 5c 24 08          	mov    0x8(%esp),%ebx
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  bb:	c1 e9 04             	shr    $0x4,%ecx
  be:	85 c9                	test   %ecx,%ecx
  c0:	74 3e                	je     100 <_Z16elf_lookupSymbolm+0x50>
  c2:	a1 00 00 00 00       	mov    0x0,%eax
  c7:	c1 e1 04             	shl    $0x4,%ecx
  ca:	01 c1                	add    %eax,%ecx
  cc:	eb 09                	jmp    d7 <_Z16elf_lookupSymbolm+0x27>
  ce:	66 90                	xchg   %ax,%ax
  d0:	83 c0 10             	add    $0x10,%eax
  d3:	39 c8                	cmp    %ecx,%eax
  d5:	74 29                	je     100 <_Z16elf_lookupSymbolm+0x50>
		if(ELF32_ST_TYPE(elf.symtab[i].info) != 0x2) {
  d7:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
  db:	83 e2 0f             	and    $0xf,%edx
  de:	80 fa 02             	cmp    $0x2,%dl
  e1:	75 ed                	jne    d0 <_Z16elf_lookupSymbolm+0x20>
			continue;
		}
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
  e3:	8b 50 04             	mov    0x4(%eax),%edx
  e6:	39 da                	cmp    %ebx,%edx
  e8:	77 e6                	ja     d0 <_Z16elf_lookupSymbolm+0x20>
  ea:	03 50 08             	add    0x8(%eax),%edx
  ed:	39 d3                	cmp    %edx,%ebx
  ef:	73 df                	jae    d0 <_Z16elf_lookupSymbolm+0x20>
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
  f1:	8b 00                	mov    (%eax),%eax
  f3:	03 05 08 00 00 00    	add    0x8,%eax
		} 

	}
	return NULL;

}
  f9:	5b                   	pop    %ebx
  fa:	c3                   	ret    
  fb:	90                   	nop
  fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
		} 

	}
	return NULL;
 100:	31 c0                	xor    %eax,%eax

}
 102:	5b                   	pop    %ebx
 103:	c3                   	ret    
 104:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 10a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000110 <_Z19elf_printStackTracev>:

extern "C" uint32_t get_ebp(void);

void elf_printStackTrace()  {
 110:	56                   	push   %esi
 111:	53                   	push   %ebx
 112:	83 ec 04             	sub    $0x4,%esp
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
 115:	e8 fc ff ff ff       	call   116 <_Z19elf_printStackTracev+0x6>
	terminal.kprintf("EBP: %x ",*ebp);
 11a:	83 ec 04             	sub    $0x4,%esp
 11d:	ff 30                	pushl  (%eax)

void elf_printStackTrace()  {
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
 11f:	89 c6                	mov    %eax,%esi
	terminal.kprintf("EBP: %x ",*ebp);
 121:	68 10 00 00 00       	push   $0x10
 126:	68 00 00 00 00       	push   $0x0
 12b:	e8 fc ff ff ff       	call   12c <_Z19elf_printStackTracev+0x1c>
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
 130:	83 c4 0c             	add    $0xc,%esp
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
 133:	8b 1e                	mov    (%esi),%ebx
	terminal.kprintf("EBP: %x ",*ebp);
 135:	ff 76 04             	pushl  0x4(%esi)
 138:	68 19 00 00 00       	push   $0x19
 13d:	68 00 00 00 00       	push   $0x0
 142:	e8 fc ff ff ff       	call   143 <_Z19elf_printStackTracev+0x33>
	while (ebp) {
 147:	83 c4 10             	add    $0x10,%esp
 14a:	85 db                	test   %ebx,%ebx
 14c:	74 53                	je     1a1 <_Z19elf_printStackTracev+0x91>
 14e:	66 90                	xchg   %ax,%ax
		terminal.kprintf("EBP: %x ",*ebp);
 150:	83 ec 04             	sub    $0x4,%esp
 153:	ff 33                	pushl  (%ebx)
 155:	68 10 00 00 00       	push   $0x10
 15a:	68 00 00 00 00       	push   $0x0
 15f:	e8 fc ff ff ff       	call   160 <_Z19elf_printStackTracev+0x50>
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
 164:	83 c4 0c             	add    $0xc,%esp
 167:	ff 73 04             	pushl  0x4(%ebx)
 16a:	68 22 00 00 00       	push   $0x22
 16f:	68 00 00 00 00       	push   $0x0
 174:	e8 fc ff ff ff       	call   175 <_Z19elf_printStackTracev+0x65>
		ebp = reinterpret_cast<uint32_t*> (*ebp);
 179:	8b 73 04             	mov    0x4(%ebx),%esi
 17c:	89 34 24             	mov    %esi,(%esp)
 17f:	e8 fc ff ff ff       	call   180 <_Z19elf_printStackTracev+0x70>
 184:	83 c4 10             	add    $0x10,%esp
 187:	50                   	push   %eax
 188:	56                   	push   %esi
 189:	68 2b 00 00 00       	push   $0x2b
 18e:	68 00 00 00 00       	push   $0x0
 193:	e8 fc ff ff ff       	call   194 <_Z19elf_printStackTracev+0x84>
	}
 198:	8b 1b                	mov    (%ebx),%ebx
	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
	while (ebp) {
 19a:	83 c4 10             	add    $0x10,%esp
 19d:	85 db                	test   %ebx,%ebx
 19f:	75 af                	jne    150 <_Z19elf_printStackTracev+0x40>
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
		ebp = reinterpret_cast<uint32_t*> (*ebp);
	}
 1a1:	83 c4 04             	add    $0x4,%esp
 1a4:	5b                   	pop    %ebx
 1a5:	5e                   	pop    %esi
 1a6:	c3                   	ret    

Disassembly of section .bss:

00000000 <elf>:
	...

Disassembly of section .rodata.str1.1:

00000000 <.rodata.str1.1>:
   0:	2e 73 74             	jae,pn 77 <_Z8elf_initP34multiboot_elf_section_header_table+0x77>
   3:	72 74                	jb     79 <_Z8elf_initP34multiboot_elf_section_header_table+0x79>
   5:	61                   	popa   
   6:	62 00                	bound  %eax,(%eax)
   8:	2e 73 79             	jae,pn 84 <_Z8elf_initP34multiboot_elf_section_header_table+0x84>
   b:	6d                   	insl   (%dx),%es:(%edi)
   c:	74 61                	je     6f <_Z8elf_initP34multiboot_elf_section_header_table+0x6f>
   e:	62 00                	bound  %eax,(%eax)
  10:	45                   	inc    %ebp
  11:	42                   	inc    %edx
  12:	50                   	push   %eax
  13:	3a 20                	cmp    (%eax),%ah
  15:	25 78 20 00 45       	and    $0x45002078,%eax
  1a:	49                   	dec    %ecx
  1b:	50                   	push   %eax
  1c:	3a 20                	cmp    (%eax),%ah
  1e:	25 78 20 00 45       	and    $0x45002078,%eax
  23:	49                   	dec    %ecx
  24:	50                   	push   %eax
  25:	3a 20                	cmp    (%eax),%ah
  27:	25 64 20 00 20       	and    $0x20002064,%eax
  2c:	5b                   	pop    %ebx
  2d:	30 78 25             	xor    %bh,0x25(%eax)
  30:	78 5d                	js     8f <_Z8elf_initP34multiboot_elf_section_header_table+0x8f>
  32:	20 25 73 20 0a 00    	and    %ah,0xa2073

Disassembly of section .debug_info:

00000000 <.debug_info>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	23 07                	and    (%edi),%eax
   2:	00 00                	add    %al,(%eax)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	04 00                	add    $0x0,%al
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   6:	00 00                	add    %al,(%eax)
   8:	00 00                	add    %al,(%eax)
   a:	04 01                	add    $0x1,%al
   c:	07                   	pop    %es
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
   d:	03 00                	add    (%eax),%eax
   f:	00 04 74             	add    %al,(%esp,%esi,2)
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);
  12:	05 00 00 33 01       	add    $0x1330000,%eax

	uint32_t shstrtab = sh[header->shndx].addr;
  17:	00 00                	add    %al,(%eax)
  19:	00 00                	add    %al,(%eax)
  1b:	00 00                	add    %al,(%eax)
  1d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
  1e:	01 00                	add    %eax,(%eax)
  20:	00 00                	add    %al,(%eax)

	for(uint32_t i = 0; i < header->num; i++) {
  22:	00 00                	add    %al,(%eax)
  24:	00 02                	add    %al,(%edx)
  26:	01 06                	add    %eax,(%esi)
  28:	ea 00 00 00 02 02 05 	ljmp   $0x502,$0x2000000
  2f:	e3 04                	jecxz  35 <.debug_info+0x35>
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
  31:	00 00                	add    %al,(%eax)
  33:	02 04 05 2a 01 00 00 	add    0x12a(,%eax,1),%al
			elf.strtabsz = sh[i].size;
  3a:	02 08                	add    (%eax),%cl
  3c:	05 dc 00 00 00       	add    $0xdc,%eax
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  41:	03 07                	add    (%edi),%eax
  43:	06                   	push   %es
  44:	00 00                	add    %al,(%eax)
  46:	02 2e                	add    (%esi),%ch
  48:	4c                   	dec    %esp
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
  49:	00 00                	add    %al,(%eax)
  4b:	00 02                	add    %al,(%edx)
  4d:	01 08                	add    %ecx,(%eax)
  4f:	b0 04                	mov    $0x4,%al
		if(!strcmp(name,".strtab")) {
  51:	00 00                	add    %al,(%eax)
  53:	03 88 01 00 00 02    	add    0x2000001(%eax),%ecx
  59:	31 5e 00             	xor    %ebx,0x0(%esi)
  5c:	00 00                	add    %al,(%eax)
  5e:	02 02                	add    (%edx),%al
  60:	07                   	pop    %es
  61:	c8 02 00 00          	enter  $0x2,$0x0
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
  65:	03 50 05             	add    0x5(%eax),%edx
  68:	00 00                	add    %al,(%eax)
  6a:	02 34 70             	add    (%eax,%esi,2),%dh
  6d:	00 00                	add    %al,(%eax)
  6f:	00 02                	add    %al,(%edx)
  71:	04 07                	add    $0x7,%al
  73:	9d                   	popf   
  74:	02 00                	add    (%eax),%al
  76:	00 02                	add    %al,(%edx)
  78:	08 07                	or     %al,(%edi)
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  7a:	74 00                	je     7c <.debug_info+0x7c>
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  7c:	00 00                	add    %al,(%eax)
  7e:	04 04                	add    $0x4,%al
  80:	05 69 6e 74 00       	add    $0x746e69,%eax
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  85:	02 04 07             	add    (%edi,%eax,1),%al
			elf.symtabsz = sh[i].size;
  88:	36 02 00             	add    %ss:(%eax),%al
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  8b:	00 03                	add    %al,(%ebx)
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
  8d:	37                   	aaa    
  8e:	04 00                	add    $0x0,%al
  90:	00 03                	add    %al,(%ebx)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  92:	60                   	pusha  
  93:	85 00                	test   %eax,(%eax)
  95:	00 00                	add    %al,(%eax)
  97:	05 5d 01 00 00       	add    $0x15d,%eax
  9c:	10 03                	adc    %al,(%ebx)
  9e:	87 d4                	xchg   %edx,%esp
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
		}
	}
}
  a0:	00 00                	add    %al,(%eax)
  a2:	00 06                	add    %al,(%esi)
  a4:	6e                   	outsb  %ds:(%esi),(%dx)
  a5:	75 6d                	jne    114 <.debug_info+0x114>
  a7:	00 03                	add    %al,(%ebx)
  a9:	89 8c 00 00 00 00 07 	mov    %ecx,0x7000000(%eax,%eax,1)

const char* elf_lookupSymbol(uint32_t addr) {
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  b0:	c3                   	ret    
  b1:	02 00                	add    (%eax),%al
  b3:	00 03                	add    %al,(%ebx)
  b5:	8a 8c 00 00 00 04 07 	mov    0x7040000(%eax,%eax,1),%cl
  bc:	91                   	xchg   %eax,%ecx
  bd:	00 00                	add    %al,(%eax)
  bf:	00 03                	add    %al,(%ebx)
  c1:	8b 8c 00 00 00 08 07 	mov    0x7080000(%eax,%eax,1),%ecx
  c8:	8b 00                	mov    (%eax),%eax
  ca:	00 00                	add    %al,(%eax)
  cc:	03 8c 8c 00 00 00 0c 	add    0xc000000(%esp,%ecx,4),%ecx
  d3:	00 03                	add    %al,(%ebx)
  d5:	89 03                	mov    %eax,(%ebx)
		if(ELF32_ST_TYPE(elf.symtab[i].info) != 0x2) {
  d7:	00 00                	add    %al,(%eax)
  d9:	03 8e 97 00 00 00    	add    0x97(%esi),%ecx
  df:	08 28                	or     %ch,(%eax)
  e1:	04 09                	add    $0x9,%al
			continue;
		}
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
  e3:	20 02                	and    %al,(%edx)
  e5:	00 00                	add    %al,(%eax)
  e7:	64 01 00             	add    %eax,%fs:(%eax)
  ea:	00 07                	add    %al,(%edi)
  ec:	b8 02 00 00 04       	mov    $0x4000002,%eax
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
  f1:	0a 65 00             	or     0x0(%ebp),%ah
  f4:	00 00                	add    %al,(%eax)
  f6:	00 07                	add    %al,(%edi)
  f8:	6f                   	outsl  %ds:(%esi),(%dx)
		} 

	}
	return NULL;

}
  f9:	00 00                	add    %al,(%eax)
  fb:	00 04 0b             	add    %al,(%ebx,%ecx,1)
  fe:	65 00 00             	add    %al,%gs:(%eax)
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
		} 

	}
	return NULL;
 101:	00 04 07             	add    %al,(%edi,%eax,1)

}
 104:	23 06                	and    (%esi),%eax
 106:	00 00                	add    %al,(%eax)
 108:	04 0c                	add    $0xc,%al
 10a:	65 00 00             	add    %al,%gs:(%eax)
 10d:	00 08                	add    %cl,(%eax)
 10f:	07                   	pop    %es

extern "C" uint32_t get_ebp(void);

void elf_printStackTrace()  {
 110:	91                   	xchg   %eax,%ecx
 111:	00 00                	add    %al,(%eax)
 113:	00 04 0d 65 00 00 00 	add    %al,0x65(,%ecx,1)
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
 11a:	0c 07                	or     $0x7,%al
 11c:	e8 05 00 00 04       	call   4000126 <_Z19elf_printStackTracev+0x4000016>
 121:	0e                   	push   %cs
 122:	65 00 00             	add    %al,%gs:(%eax)
 125:	00 10                	add    %dl,(%eax)
 127:	07                   	pop    %es
 128:	c3                   	ret    
 129:	02 00                	add    (%eax),%al
 12b:	00 04 0f             	add    %al,(%edi,%ecx,1)
 12e:	65 00 00             	add    %al,%gs:(%eax)
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
 131:	00 14 07             	add    %dl,(%edi,%eax,1)
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
 134:	f6 01 00             	testb  $0x0,(%ecx)
	terminal.kprintf("EBP: %x ",*ebp);
 137:	00 04 10             	add    %al,(%eax,%edx,1)
 13a:	65 00 00             	add    %al,%gs:(%eax)
 13d:	00 18                	add    %bl,(%eax)
 13f:	07                   	pop    %es
 140:	ed                   	in     (%dx),%eax
 141:	04 00                	add    $0x0,%al
 143:	00 04 11             	add    %al,(%ecx,%edx,1)
 146:	65 00 00             	add    %al,%gs:(%eax)
	while (ebp) {
 149:	00 1c 07             	add    %bl,(%edi,%eax,1)
 14c:	1a 05 00 00 04 12    	sbb    0x12040000,%al
		terminal.kprintf("EBP: %x ",*ebp);
 152:	65 00 00             	add    %al,%gs:(%eax)
 155:	00 20                	add    %ah,(%eax)
 157:	07                   	pop    %es
 158:	c8 00 00 00          	enter  $0x0,$0x0
 15c:	04 13                	add    $0x13,%al
 15e:	65 00 00             	add    %al,%gs:(%eax)
 161:	00 24 00             	add    %ah,(%eax,%eax,1)
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
 164:	03 f2                	add    %edx,%esi
 166:	04 00                	add    $0x0,%al
 168:	00 04 14             	add    %al,(%esp,%edx,1)
 16b:	df 00                	fild   (%eax)
 16d:	00 00                	add    %al,(%eax)
 16f:	08 10                	or     %dl,(%eax)
 171:	04 16                	add    $0x16,%al
 173:	66 03 00             	add    (%eax),%ax
 176:	00 c4                	add    %al,%ah
 178:	01 00                	add    %eax,(%eax)
		ebp = reinterpret_cast<uint32_t*> (*ebp);
 17a:	00 07                	add    %al,(%edi)
 17c:	b8 02 00 00 04       	mov    $0x4000002,%eax
 181:	17                   	pop    %ss
 182:	65 00 00             	add    %al,%gs:(%eax)
 185:	00 00                	add    %al,(%eax)
 187:	07                   	pop    %es
 188:	1a 02                	sbb    (%edx),%al
 18a:	00 00                	add    %al,(%eax)
 18c:	04 18                	add    $0x18,%al
 18e:	65 00 00             	add    %al,%gs:(%eax)
 191:	00 04 07             	add    %al,(%edi,%eax,1)
 194:	c3                   	ret    
 195:	02 00                	add    (%eax),%al
 197:	00 04 19             	add    %al,(%ecx,%ebx,1)
	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
	while (ebp) {
 19a:	65 00 00             	add    %al,%gs:(%eax)
 19d:	00 08                	add    %cl,(%eax)
 19f:	07                   	pop    %es
 1a0:	ed                   	in     (%dx),%eax
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
		ebp = reinterpret_cast<uint32_t*> (*ebp);
	}
 1a1:	04 00                	add    $0x0,%al
 1a3:	00 04 1a             	add    %al,(%edx,%ebx,1)
 1a6:	41                   	inc    %ecx
 1a7:	00 00                	add    %al,(%eax)
 1a9:	00 0c 07             	add    %cl,(%edi,%eax,1)
 1ac:	f6 00 00             	testb  $0x0,(%eax)
 1af:	00 04 1b             	add    %al,(%ebx,%ebx,1)
 1b2:	41                   	inc    %ecx
 1b3:	00 00                	add    %al,(%eax)
 1b5:	00 0d 07 8b 00 00    	add    %cl,0x8b07
 1bb:	00 04 1c             	add    %al,(%esp,%ebx,1)
 1be:	53                   	push   %ebx
 1bf:	00 00                	add    %al,(%eax)
 1c1:	00 0e                	add    %cl,(%esi)
 1c3:	00 03                	add    %al,(%ebx)
 1c5:	0d 02 00 00 04       	or     $0x4000002,%eax
 1ca:	1d 6f 01 00 00       	sbb    $0x16f,%eax
 1cf:	08 10                	or     %dl,(%eax)
 1d1:	04 1f                	add    $0x1f,%al
 1d3:	2b 04 00             	sub    (%eax,%eax,1),%eax
 1d6:	00 0c 02             	add    %cl,(%edx,%eax,1)
 1d9:	00 00                	add    %al,(%eax)
 1db:	07                   	pop    %es
 1dc:	60                   	pusha  
 1dd:	00 00                	add    %al,(%eax)
 1df:	00 04 20             	add    %al,(%eax,%eiz,1)
 1e2:	0c 02                	or     $0x2,%al
 1e4:	00 00                	add    %al,(%eax)
 1e6:	00 07                	add    %al,(%edi)
 1e8:	af                   	scas   %es:(%edi),%eax
 1e9:	02 00                	add    (%eax),%al
 1eb:	00 04 21             	add    %al,(%ecx,%eiz,1)
 1ee:	65 00 00             	add    %al,%gs:(%eax)
 1f1:	00 04 07             	add    %al,(%edi,%eax,1)
 1f4:	7a 02                	jp     1f8 <.debug_info+0x1f8>
 1f6:	00 00                	add    %al,(%eax)
 1f8:	04 22                	add    $0x22,%al
 1fa:	12 02                	adc    (%edx),%al
 1fc:	00 00                	add    %al,(%eax)
 1fe:	08 07                	or     %al,(%edi)
 200:	3b 05 00 00 04 23    	cmp    0x23040000,%eax
 206:	65 00 00             	add    %al,%gs:(%eax)
 209:	00 0c 00             	add    %cl,(%eax,%eax,1)
 20c:	09 04 c4             	or     %eax,(%esp,%eax,8)
 20f:	01 00                	add    %eax,(%eax)
 211:	00 09                	add    %cl,(%ecx)
 213:	04 18                	add    $0x18,%al
 215:	02 00                	add    (%eax),%al
 217:	00 0a                	add    %cl,(%edx)
 219:	1d 02 00 00 02       	sbb    $0x2000002,%eax
 21e:	01 06                	add    %eax,(%esi)
 220:	64                   	fs
 221:	05 00 00 03 43       	add    $0x43030000,%eax
 226:	02 00                	add    (%eax),%al
 228:	00 04 24             	add    %al,(%esp)
 22b:	cf                   	iret   
 22c:	01 00                	add    %eax,(%eax)
 22e:	00 03                	add    %al,(%ebx)
 230:	59                   	pop    %ecx
 231:	00 00                	add    %al,(%eax)
 233:	00 05 d4 70 00 00    	add    %al,0x70d4
 239:	00 03                	add    %al,(%ebx)
 23b:	b8 03 00 00 06       	mov    $0x6000003,%eax
 240:	28 45 02             	sub    %al,0x2(%ebp)
 243:	00 00                	add    %al,(%eax)
 245:	0b 04 4b             	or     (%ebx,%ecx,2),%eax
 248:	01 00                	add    %eax,(%eax)
 24a:	00 1d 02 00 00 03    	add    %bl,0x3000002
 250:	67 00 00             	add    %al,(%bx,%si)
 253:	00 06                	add    %al,(%esi)
 255:	62 3a                	bound  %edi,(%edx)
 257:	02 00                	add    (%eax),%al
 259:	00 0c 04             	add    %cl,(%esp,%eax,1)
 25c:	02 00                	add    (%eax),%al
 25e:	00 14 07             	add    %dl,(%edi,%eax,1)
 261:	0c 4f                	or     $0x4f,%al
 263:	05 00 00 0d 8b       	add    $0x8b0d0000,%eax
 268:	06                   	push   %es
 269:	00 00                	add    %al,(%eax)
 26b:	04 07                	add    $0x7,%al
 26d:	0e                   	push   %cs
 26e:	01 d4                	add    %edx,%esp
 270:	02 00                	add    (%eax),%al
 272:	00 0e                	add    %cl,(%esi)
 274:	a4                   	movsb  %ds:(%esi),%es:(%edi)
 275:	04 00                	add    $0x0,%al
 277:	00 00                	add    %al,(%eax)
 279:	0e                   	push   %cs
 27a:	75 03                	jne    27f <.debug_info+0x27f>
 27c:	00 00                	add    %al,(%eax)
 27e:	01 0e                	add    %ecx,(%esi)
 280:	44                   	inc    %esp
 281:	05 00 00 02 0e       	add    $0xe020000,%eax
 286:	ea 02 00 00 03 0e 00 	ljmp   $0xe,$0x3000002
 28d:	00 00                	add    %al,(%eax)
 28f:	00 04 0e             	add    %al,(%esi,%ecx,1)
 292:	ca 01 00             	lret   $0x1
 295:	00 05 0e d0 00 00    	add    %al,0xd00e
 29b:	00 06                	add    %al,(%esi)
 29d:	0e                   	push   %cs
 29e:	b9 01 00 00 07       	mov    $0x7000001,%ecx
 2a3:	0e                   	push   %cs
 2a4:	fc                   	cld    
 2a5:	00 00                	add    %al,(%eax)
 2a7:	00 08                	add    %cl,(%eax)
 2a9:	0e                   	push   %cs
 2aa:	68 06 00 00 09       	push   $0x9000006
 2af:	0e                   	push   %cs
 2b0:	24 05                	and    $0x5,%al
 2b2:	00 00                	add    %al,(%eax)
 2b4:	0a 0e                	or     (%esi),%cl
 2b6:	f6 05 00 00 0b 0e 49 	testb  $0x49,0xe0b0000
 2bd:	00 00                	add    %al,(%eax)
 2bf:	00 0c 0e             	add    %cl,(%esi,%ecx,1)
 2c2:	b4 00                	mov    $0x0,%ah
 2c4:	00 00                	add    %al,(%eax)
 2c6:	0d 0e 96 00 00       	or     $0x960e,%eax
 2cb:	00 0e                	add    %cl,(%esi)
 2cd:	0e                   	push   %cs
 2ce:	a8 00                	test   $0x0,%al
 2d0:	00 00                	add    %al,(%eax)
 2d2:	0f 00 0f             	str    (%edi)
 2d5:	72 6f                	jb     346 <.debug_info+0x346>
 2d7:	77 00                	ja     2d9 <.debug_info+0x2d9>
 2d9:	07                   	pop    %es
 2da:	32 2f                	xor    (%edi),%ch
 2dc:	02 00                	add    (%eax),%al
 2de:	00 00                	add    %al,(%eax)
 2e0:	02 10                	add    (%eax),%dl
 2e2:	ef                   	out    %eax,(%dx)
 2e3:	05 00 00 07 33       	add    $0x33070000,%eax
 2e8:	2f                   	das    
 2e9:	02 00                	add    (%eax),%al
 2eb:	00 04 02             	add    %al,(%edx,%eax,1)
 2ee:	10 23                	adc    %ah,(%ebx)
 2f0:	04 00                	add    $0x0,%al
 2f2:	00 07                	add    %al,(%edi)
 2f4:	34 7e                	xor    $0x7e,%al
 2f6:	00 00                	add    %al,(%eax)
 2f8:	00 08                	add    %cl,(%eax)
 2fa:	02 10                	add    (%eax),%dl
 2fc:	fa                   	cli    
 2fd:	02 00                	add    (%eax),%al
 2ff:	00 07                	add    %al,(%edi)
 301:	35 41 00 00 00       	xor    $0x41,%eax
 306:	0c 02                	or     $0x2,%al
 308:	10 b1 05 00 00 07    	adc    %dh,0x7000005(%ecx)
 30e:	36                   	ss
 30f:	4f                   	dec    %edi
 310:	05 00 00 10 02       	add    $0x2100000,%eax
 315:	11 bd 02 00 00 07    	adc    %edi,0x7000002(%ebp)
 31b:	37                   	aaa    
 31c:	55                   	push   %ebp
 31d:	05 00 00 02 50       	add    $0x50020000,%eax
 322:	11 dc                	adc    %ebx,%esp
 324:	04 00                	add    $0x0,%al
 326:	00 07                	add    %al,(%edi)
 328:	38 55 05             	cmp    %dl,0x5(%ebp)
 32b:	00 00                	add    %al,(%eax)
 32d:	02 19                	add    (%ecx),%bl
 32f:	12 04 02             	adc    (%edx,%eax,1),%al
 332:	00 00                	add    %al,(%eax)
 334:	07                   	pop    %es
 335:	22 01                	and    (%ecx),%al
 337:	3f                   	aas    
 338:	03 00                	add    (%eax),%eax
 33a:	00 45 03             	add    %al,0x3(%ebp)
 33d:	00 00                	add    %al,(%eax)
 33f:	13 5a 05             	adc    0x5(%edx),%ebx
 342:	00 00                	add    %al,(%eax)
 344:	00 14 32             	add    %dl,(%edx,%esi,1)
 347:	04 00                	add    $0x0,%al
 349:	00 07                	add    %al,(%edi)
 34b:	23 06                	and    (%esi),%eax
 34d:	05 00 00 01 59       	add    $0x59010000,%eax
 352:	03 00                	add    (%eax),%eax
 354:	00 5f 03             	add    %bl,0x3(%edi)
 357:	00 00                	add    %al,(%eax)
 359:	13 5a 05             	adc    0x5(%edx),%ebx
 35c:	00 00                	add    %al,(%eax)
 35e:	00 15 ae 03 00 00    	add    %dl,0x3ae
 364:	07                   	pop    %es
 365:	24 88                	and    $0x88,%al
 367:	05 00 00 41 00       	add    $0x410000,%eax
 36c:	00 00                	add    %al,(%eax)
 36e:	01 77 03             	add    %esi,0x3(%edi)
 371:	00 00                	add    %al,(%eax)
 373:	87 03                	xchg   %eax,(%ebx)
 375:	00 00                	add    %al,(%eax)
 377:	13 5a 05             	adc    0x5(%edx),%ebx
 37a:	00 00                	add    %al,(%eax)
 37c:	16                   	push   %ss
 37d:	66                   	data16
 37e:	02 00                	add    (%eax),%al
 380:	00 16                	add    %dl,(%esi)
 382:	66                   	data16
 383:	02 00                	add    (%eax),%al
 385:	00 00                	add    %al,(%eax)
 387:	14 40                	adc    $0x40,%al
 389:	00 00                	add    %al,(%eax)
 38b:	00 07                	add    %al,(%edi)
 38d:	25 29 06 00 00       	and    $0x629,%eax
 392:	01 9b 03 00 00 a6    	add    %ebx,-0x59fffffd(%ebx)
 398:	03 00                	add    (%eax),%eax
 39a:	00 13                	add    %dl,(%ebx)
 39c:	5a                   	pop    %edx
 39d:	05 00 00 16 41       	add    $0x41160000,%eax
 3a2:	00 00                	add    %al,(%eax)
 3a4:	00 00                	add    %al,(%eax)
 3a6:	14 59                	adc    $0x59,%al
 3a8:	05 00 00 07 26       	add    $0x26070000,%eax
 3ad:	9e                   	sahf   
 3ae:	01 00                	add    %eax,(%eax)
 3b0:	00 01                	add    %al,(%ecx)
 3b2:	ba 03 00 00 c0       	mov    $0xc0000003,%edx
 3b7:	03 00                	add    (%eax),%eax
 3b9:	00 13                	add    %dl,(%ebx)
 3bb:	5a                   	pop    %edx
 3bc:	05 00 00 00 14       	add    $0x14000000,%eax
 3c1:	71 04                	jno    3c7 <.debug_info+0x3c7>
 3c3:	00 00                	add    %al,(%eax)
 3c5:	07                   	pop    %es
 3c6:	27                   	daa    
 3c7:	79 04                	jns    3cd <.debug_info+0x3cd>
 3c9:	00 00                	add    %al,(%eax)
 3cb:	01 d4                	add    %edx,%esp
 3cd:	03 00                	add    (%eax),%eax
 3cf:	00 e0                	add    %ah,%al
 3d1:	03 00                	add    (%eax),%eax
 3d3:	00 13                	add    %dl,(%ebx)
 3d5:	5a                   	pop    %edx
 3d6:	05 00 00 16 12       	add    $0x12160000,%eax
 3db:	02 00                	add    (%eax),%al
 3dd:	00 17                	add    %dl,(%edi)
 3df:	00 14 e1             	add    %dl,(%ecx,%eiz,8)
 3e2:	02 00                	add    (%eax),%al
 3e4:	00 07                	add    %al,(%edi)
 3e6:	28 81 02 00 00 01    	sub    %al,0x1000002(%ecx)
 3ec:	f4                   	hlt    
 3ed:	03 00                	add    (%eax),%eax
 3ef:	00 04 04             	add    %al,(%esp,%eax,1)
 3f2:	00 00                	add    %al,(%eax)
 3f4:	13 5a 05             	adc    0x5(%edx),%ebx
 3f7:	00 00                	add    %al,(%eax)
 3f9:	16                   	push   %ss
 3fa:	12 02                	adc    (%edx),%al
 3fc:	00 00                	add    %al,(%eax)
 3fe:	16                   	push   %ss
 3ff:	4f                   	dec    %edi
 400:	02 00                	add    (%eax),%al
 402:	00 00                	add    %al,(%eax)
 404:	14 db                	adc    $0xdb,%al
 406:	02 00                	add    (%eax),%al
 408:	00 07                	add    %al,(%edi)
 40a:	29 b8 05 00 00 01    	sub    %edi,0x1000005(%eax)
 410:	18 04 00             	sbb    %al,(%eax,%eax,1)
 413:	00 23                	add    %ah,(%ebx)
 415:	04 00                	add    $0x0,%al
 417:	00 13                	add    %dl,(%ebx)
 419:	5a                   	pop    %edx
 41a:	05 00 00 16 12       	add    $0x12160000,%eax
 41f:	02 00                	add    (%eax),%al
 421:	00 00                	add    %al,(%eax)
 423:	14 d8                	adc    $0xd8,%al
 425:	01 00                	add    %eax,(%eax)
 427:	00 07                	add    %al,(%edi)
 429:	2a 41 06             	sub    0x6(%ecx),%al
 42c:	00 00                	add    %al,(%eax)
 42e:	01 37                	add    %esi,(%edi)
 430:	04 00                	add    $0x0,%al
 432:	00 42 04             	add    %al,0x4(%edx)
 435:	00 00                	add    %al,(%eax)
 437:	13 5a 05             	adc    0x5(%edx),%ebx
 43a:	00 00                	add    %al,(%eax)
 43c:	16                   	push   %ss
 43d:	12 02                	adc    (%edx),%al
 43f:	00 00                	add    %al,(%eax)
 441:	00 14 3a             	add    %dl,(%edx,%edi,1)
 444:	00 00                	add    %al,(%eax)
 446:	00 07                	add    %al,(%edi)
 448:	2b df                	sub    %edi,%ebx
 44a:	01 00                	add    %eax,(%eax)
 44c:	00 01                	add    %al,(%ecx)
 44e:	56                   	push   %esi
 44f:	04 00                	add    $0x0,%al
 451:	00 61 04             	add    %ah,0x4(%ecx)
 454:	00 00                	add    %al,(%eax)
 456:	13 5a 05             	adc    0x5(%edx),%ebx
 459:	00 00                	add    %al,(%eax)
 45b:	16                   	push   %ss
 45c:	12 02                	adc    (%edx),%al
 45e:	00 00                	add    %al,(%eax)
 460:	00 14 4a             	add    %dl,(%edx,%ecx,2)
 463:	04 00                	add    $0x0,%al
 465:	00 07                	add    %al,(%edi)
 467:	2c cf                	sub    $0xcf,%al
 469:	05 00 00 01 75       	add    $0x75010000,%eax
 46e:	04 00                	add    $0x0,%al
 470:	00 80 04 00 00 13    	add    %al,0x13000004(%eax)
 476:	5a                   	pop    %edx
 477:	05 00 00 16 60       	add    $0x60160000,%eax
 47c:	05 00 00 00 14       	add    $0x14000000,%eax
 481:	91                   	xchg   %eax,%ecx
 482:	01 00                	add    %eax,(%eax)
 484:	00 07                	add    %al,(%edi)
 486:	2e                   	cs
 487:	0c 01                	or     $0x1,%al
 489:	00 00                	add    %al,(%eax)
 48b:	01 94 04 00 00 a4 04 	add    %edx,0x4a40000(%esp,%eax,1)
 492:	00 00                	add    %al,(%eax)
 494:	13 5a 05             	adc    0x5(%edx),%ebx
 497:	00 00                	add    %al,(%eax)
 499:	16                   	push   %ss
 49a:	2f                   	das    
 49b:	02 00                	add    (%eax),%al
 49d:	00 16                	add    %dl,(%esi)
 49f:	2f                   	das    
 4a0:	02 00                	add    (%eax),%al
 4a2:	00 00                	add    %al,(%eax)
 4a4:	14 36                	adc    $0x36,%al
 4a6:	05 00 00 07 2f       	add    $0x2f070000,%eax
 4ab:	0f 06                	clts   
 4ad:	00 00                	add    %al,(%eax)
 4af:	01 b8 04 00 00 be    	add    %edi,-0x41fffffc(%eax)
 4b5:	04 00                	add    $0x0,%al
 4b7:	00 13                	add    %dl,(%ebx)
 4b9:	5a                   	pop    %edx
 4ba:	05 00 00 00 14       	add    $0x14000000,%eax
 4bf:	95                   	xchg   %eax,%ebp
 4c0:	06                   	push   %es
 4c1:	00 00                	add    %al,(%eax)
 4c3:	07                   	pop    %es
 4c4:	30 54 04 00          	xor    %dl,0x0(%esp,%eax,1)
 4c8:	00 01                	add    %al,(%ecx)
 4ca:	d2 04 00             	rolb   %cl,(%eax,%eax,1)
 4cd:	00 dd                	add    %bl,%ch
 4cf:	04 00                	add    $0x0,%al
 4d1:	00 13                	add    %dl,(%ebx)
 4d3:	5a                   	pop    %edx
 4d4:	05 00 00 16 12       	add    $0x12160000,%eax
 4d9:	02 00                	add    (%eax),%al
 4db:	00 00                	add    %al,(%eax)
 4dd:	15 79 06 00 00       	adc    $0x679,%eax
 4e2:	07                   	pop    %es
 4e3:	3a 0a                	cmp    (%edx),%cl
 4e5:	04 00                	add    $0x0,%al
 4e7:	00 53 00             	add    %dl,0x0(%ebx)
 4ea:	00 00                	add    %al,(%eax)
 4ec:	02 f5                	add    %ch,%dh
 4ee:	04 00                	add    $0x0,%al
 4f0:	00 05 05 00 00 13    	add    %al,0x13000005
 4f6:	5a                   	pop    %edx
 4f7:	05 00 00 16 1d       	add    $0x1d160000,%eax
 4fc:	02 00                	add    (%eax),%al
 4fe:	00 16                	add    %dl,(%esi)
 500:	41                   	inc    %ecx
 501:	00 00                	add    %al,(%eax)
 503:	00 00                	add    %al,(%eax)
 505:	14 69                	adc    $0x69,%al
 507:	05 00 00 07 3b       	add    $0x3b070000,%eax
 50c:	be 04 00 00 02       	mov    $0x2000004,%esi
 511:	19 05 00 00 33 05    	sbb    %eax,0x5330000
 517:	00 00                	add    %al,(%eax)
 519:	13 5a 05             	adc    0x5(%edx),%ebx
 51c:	00 00                	add    %al,(%eax)
 51e:	16                   	push   %ss
 51f:	1d 02 00 00 16       	sbb    $0x16000002,%eax
 524:	41                   	inc    %ecx
 525:	00 00                	add    %al,(%eax)
 527:	00 16                	add    %dl,(%esi)
 529:	2f                   	das    
 52a:	02 00                	add    (%eax),%al
 52c:	00 16                	add    %dl,(%esi)
 52e:	2f                   	das    
 52f:	02 00                	add    (%eax),%al
 531:	00 00                	add    %al,(%eax)
 533:	18 80 01 00 00 07    	sbb    %al,0x7000001(%eax)
 539:	3c 23                	cmp    $0x23,%al
 53b:	00 00                	add    %al,(%eax)
 53d:	00 02                	add    %al,(%edx)
 53f:	43                   	inc    %ebx
 540:	05 00 00 13 5a       	add    $0x5a130000,%eax
 545:	05 00 00 16 1d       	add    $0x1d160000,%eax
 54a:	02 00                	add    (%eax),%al
 54c:	00 00                	add    %al,(%eax)
 54e:	00 09                	add    %cl,(%ecx)
 550:	04 53                	add    $0x53,%al
 552:	00 00                	add    %al,(%eax)
 554:	00 0a                	add    %cl,(%edx)
 556:	2f                   	das    
 557:	02 00                	add    (%eax),%al
 559:	00 09                	add    %cl,(%ecx)
 55b:	04 5a                	add    $0x5a,%al
 55d:	02 00                	add    (%eax),%al
 55f:	00 02                	add    %al,(%edx)
 561:	01 02                	add    %eax,(%edx)
 563:	f5                   	cmc    
 564:	02 00                	add    (%eax),%al
 566:	00 19                	add    %bl,(%ecx)
 568:	01 04 00             	add    %eax,(%eax,%eax,1)
 56b:	00 01                	add    %al,(%ecx)
 56d:	07                   	pop    %es
 56e:	49                   	dec    %ecx
 56f:	02 00                	add    (%eax),%al
 571:	00 00                	add    %al,(%eax)
 573:	00 00                	add    %al,(%eax)
 575:	00 a8 00 00 00 01    	add    %ch,0x1000000(%eax)
 57b:	9c                   	pushf  
 57c:	ec                   	in     (%dx),%al
 57d:	05 00 00 1a 61       	add    $0x611a0000,%eax
 582:	06                   	push   %es
 583:	00 00                	add    %al,(%eax)
 585:	01 07                	add    %eax,(%edi)
 587:	ec                   	in     (%dx),%al
 588:	05 00 00 02 91       	add    $0x91020000,%eax
 58d:	00 1b                	add    %bl,(%ebx)
 58f:	00 00                	add    %al,(%eax)
 591:	00 00                	add    %al,(%eax)
 593:	1c 73                	sbb    $0x73,%al
 595:	68 00 01 08 f2       	push   $0xf2080100
 59a:	05 00 00 00 00       	add    $0x0,%eax
 59f:	00 00                	add    %al,(%eax)
 5a1:	1d 82 06 00 00       	sbb    $0x682,%eax
 5a6:	01 0a                	add    %ecx,(%edx)
 5a8:	65 00 00             	add    %al,%gs:(%eax)
 5ab:	00 1f                	add    %bl,(%edi)
 5ad:	00 00                	add    %al,(%eax)
 5af:	00 1b                	add    %bl,(%ebx)
 5b1:	18 00                	sbb    %al,(%eax)
 5b3:	00 00                	add    %al,(%eax)
 5b5:	1c 69                	sbb    $0x69,%al
 5b7:	00 01                	add    %al,(%ecx)
 5b9:	0c 65                	or     $0x65,%al
 5bb:	00 00                	add    %al,(%eax)
 5bd:	00 55 00             	add    %dl,0x0(%ebp)
 5c0:	00 00                	add    %al,(%eax)
 5c2:	1b 30                	sbb    (%eax),%esi
 5c4:	00 00                	add    %al,(%eax)
 5c6:	00 1d b8 02 00 00    	add    %bl,0x2b8
 5cc:	01 0d 12 02 00 00    	add    %ecx,0x212
 5d2:	74 00                	je     5d4 <.debug_info+0x5d4>
 5d4:	00 00                	add    %al,(%eax)
 5d6:	1e                   	push   %ds
 5d7:	5e                   	pop    %esi
 5d8:	00 00                	add    %al,(%eax)
 5da:	00 fd                	add    %bh,%ch
 5dc:	06                   	push   %es
 5dd:	00 00                	add    %al,(%eax)
 5df:	1e                   	push   %ds
 5e0:	73 00                	jae    5e2 <.debug_info+0x5e2>
 5e2:	00 00                	add    %al,(%eax)
 5e4:	fd                   	std    
 5e5:	06                   	push   %es
 5e6:	00 00                	add    %al,(%eax)
 5e8:	00 00                	add    %al,(%eax)
 5ea:	00 00                	add    %al,(%eax)
 5ec:	09 04 d4             	or     %eax,(%esp,%edx,8)
 5ef:	00 00                	add    %al,(%eax)
 5f1:	00 09                	add    %cl,(%ecx)
 5f3:	04 64                	add    $0x64,%al
 5f5:	01 00                	add    %eax,(%eax)
 5f7:	00 1f                	add    %bl,(%edi)
 5f9:	93                   	xchg   %eax,%ebx
 5fa:	04 00                	add    $0x0,%al
 5fc:	00 01                	add    %al,(%ecx)
 5fe:	18 d7                	sbb    %dl,%bh
 600:	03 00                	add    (%eax),%eax
 602:	00 12                	add    %dl,(%edx)
 604:	02 00                	add    (%eax),%al
 606:	00 b0 00 00 00 54    	add    %dh,0x54000000(%eax)
 60c:	00 00                	add    %al,(%eax)
 60e:	00 01                	add    %al,(%ecx)
 610:	9c                   	pushf  
 611:	38 06                	cmp    %al,(%esi)
 613:	00 00                	add    %al,(%eax)
 615:	20 91 00 00 00 01    	and    %dl,0x1000000(%ecx)
 61b:	18 65 00             	sbb    %ah,0x0(%ebp)
 61e:	00 00                	add    %al,(%eax)
 620:	92                   	xchg   %eax,%edx
 621:	00 00                	add    %al,(%eax)
 623:	00 1b                	add    %bl,(%ebx)
 625:	58                   	pop    %eax
 626:	00 00                	add    %al,(%eax)
 628:	00 1c 69             	add    %bl,(%ecx,%ebp,2)
 62b:	00 01                	add    %al,(%ecx)
 62d:	19 65 00             	sbb    %esp,0x0(%ebp)
 630:	00 00                	add    %al,(%eax)
 632:	bd 00 00 00 00       	mov    $0x0,%ebp
 637:	00 19                	add    %bl,(%ecx)
 639:	ed                   	in     (%dx),%eax
 63a:	03 00                	add    (%eax),%eax
 63c:	00 01                	add    %al,(%ecx)
 63e:	28 0a                	sub    %cl,(%edx)
 640:	00 00                	add    %al,(%eax)
 642:	00 10                	add    %dl,(%eax)
 644:	01 00                	add    %eax,(%eax)
 646:	00 97 00 00 00 01    	add    %dl,0x1000000(%edi)
 64c:	9c                   	pushf  
 64d:	c4 06                	les    (%esi),%eax
 64f:	00 00                	add    %al,(%eax)
 651:	21 15 01 00 00 8c    	and    %edx,0x8c000001
 657:	00 00                	add    %al,(%eax)
 659:	00 1c 65 62 70 00 01 	add    %bl,0x1007062(,%eiz,2)
 660:	29 c4                	sub    %eax,%esp
 662:	06                   	push   %es
 663:	00 00                	add    %al,(%eax)
 665:	d1 00                	roll   (%eax)
 667:	00 00                	add    %al,(%eax)
 669:	1c 65                	sbb    $0x65,%al
 66b:	69 70 00 01 29 c4 06 	imul   $0x6c42901,0x0(%eax),%esi
 672:	00 00                	add    %al,(%eax)
 674:	fa                   	cli    
 675:	00 00                	add    %al,(%eax)
 677:	00 22                	add    %ah,(%edx)
 679:	b1 05                	mov    $0x5,%cl
 67b:	00 00                	add    %al,(%eax)
 67d:	01 2a                	add    %ebp,(%edx)
 67f:	ca 06 00             	lret   $0x6
 682:	00 1e                	add    %bl,(%esi)
 684:	1a 01                	sbb    (%ecx),%al
 686:	00 00                	add    %al,(%eax)
 688:	1b 07                	sbb    (%edi),%eax
 68a:	00 00                	add    %al,(%eax)
 68c:	1e                   	push   %ds
 68d:	30 01                	xor    %al,(%ecx)
 68f:	00 00                	add    %al,(%eax)
 691:	c0 03 00             	rolb   $0x0,(%ebx)
 694:	00 1e                	add    %bl,(%esi)
 696:	47                   	inc    %edi
 697:	01 00                	add    %eax,(%eax)
 699:	00 c0                	add    %al,%al
 69b:	03 00                	add    (%eax),%eax
 69d:	00 1e                	add    %bl,(%esi)
 69f:	64 01 00             	add    %eax,%fs:(%eax)
 6a2:	00 c0                	add    %al,%al
 6a4:	03 00                	add    (%eax),%eax
 6a6:	00 1e                	add    %bl,(%esi)
 6a8:	79 01                	jns    6ab <.debug_info+0x6ab>
 6aa:	00 00                	add    %al,(%eax)
 6ac:	c0 03 00             	rolb   $0x0,(%ebx)
 6af:	00 1e                	add    %bl,(%esi)
 6b1:	84 01                	test   %al,(%ecx)
 6b3:	00 00                	add    %al,(%eax)
 6b5:	f8                   	clc    
 6b6:	05 00 00 1e 98       	add    $0x981e0000,%eax
 6bb:	01 00                	add    %eax,(%eax)
 6bd:	00 c0                	add    %al,%al
 6bf:	03 00                	add    (%eax),%eax
 6c1:	00 00                	add    %al,(%eax)
 6c3:	00 09                	add    %cl,(%ecx)
 6c5:	04 65                	add    $0x65,%al
 6c7:	00 00                	add    %al,(%eax)
 6c9:	00 23                	add    %ah,(%ebx)
 6cb:	1d 02 00 00 da       	sbb    $0xda000002,%eax
 6d0:	06                   	push   %es
 6d1:	00 00                	add    %al,(%eax)
 6d3:	24 da                	and    $0xda,%al
 6d5:	06                   	push   %es
 6d6:	00 00                	add    %al,(%eax)
 6d8:	40                   	inc    %eax
 6d9:	00 02                	add    %al,(%edx)
 6db:	04 07                	add    $0x7,%al
 6dd:	80 03 00             	addb   $0x0,(%ebx)
 6e0:	00 25 fb 01 00 00    	add    %ah,0x1fb
 6e6:	09 06                	or     %eax,(%esi)
 6e8:	5a                   	pop    %edx
 6e9:	02 00                	add    (%eax),%al
 6eb:	00 26                	add    %ah,(%esi)
 6ed:	65                   	gs
 6ee:	6c                   	insb   (%dx),%es:(%edi)
 6ef:	66                   	data16
 6f0:	00 01                	add    %al,(%ecx)
 6f2:	05 24 02 00 00       	add    $0x224,%eax
 6f7:	05 03 00 00 00       	add    $0x3,%eax
 6fc:	00 27                	add    %ah,(%edi)
 6fe:	00 03                	add    %al,(%ebx)
 700:	00 00                	add    %al,(%eax)
 702:	08 07                	or     %al,(%edi)
 704:	c7 03 00 00 2f 02    	movl   $0x22f0000,(%ebx)
 70a:	00 00                	add    %al,(%eax)
 70c:	1b 07                	sbb    (%edi),%eax
 70e:	00 00                	add    %al,(%eax)
 710:	16                   	push   %ss
 711:	12 02                	adc    (%edx),%al
 713:	00 00                	add    %al,(%eax)
 715:	16                   	push   %ss
 716:	12 02                	adc    (%edx),%al
 718:	00 00                	add    %al,(%eax)
 71a:	00 28                	add    %ch,(%eax)
 71c:	59                   	pop    %ecx
 71d:	06                   	push   %es
 71e:	00 00                	add    %al,(%eax)
 720:	01 26                	add    %esp,(%esi)
 722:	65 00 00             	add    %al,%gs:(%eax)
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	01 11                	add    %edx,(%ecx)
   2:	01 25 0e 13 0b 03    	add    %esp,0x30b130e
   8:	0e                   	push   %cs
   9:	1b 0e                	sbb    (%esi),%ecx
   b:	11 01                	adc    %eax,(%ecx)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
   d:	12 06                	adc    (%esi),%al
   f:	10 17                	adc    %dl,(%edi)
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);
  11:	00 00                	add    %al,(%eax)

	uint32_t shstrtab = sh[header->shndx].addr;
  13:	02 24 00             	add    (%eax,%eax,1),%ah
  16:	0b 0b                	or     (%ebx),%ecx
  18:	3e 0b 03             	or     %ds:(%ebx),%eax
  1b:	0e                   	push   %cs
  1c:	00 00                	add    %al,(%eax)
  1e:	03 16                	add    (%esi),%edx
  20:	00 03                	add    %al,(%ebx)

	for(uint32_t i = 0; i < header->num; i++) {
  22:	0e                   	push   %cs
  23:	3a 0b                	cmp    (%ebx),%cl
  25:	3b 0b                	cmp    (%ebx),%ecx
  27:	49                   	dec    %ecx
  28:	13 00                	adc    (%eax),%eax
  2a:	00 04 24             	add    %al,(%esp)
  2d:	00 0b                	add    %cl,(%ebx)
  2f:	0b 3e                	or     (%esi),%edi
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
  31:	0b 03                	or     (%ebx),%eax
  33:	08 00                	or     %al,(%eax)
  35:	00 05 13 01 03 0e    	add    %al,0xe030113
			elf.strtabsz = sh[i].size;
  3b:	0b 0b                	or     (%ebx),%ecx
  3d:	3a 0b                	cmp    (%ebx),%cl
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  3f:	3b 0b                	cmp    (%ebx),%ecx
  41:	01 13                	add    %edx,(%ebx)
  43:	00 00                	add    %al,(%eax)
  45:	06                   	push   %es
  46:	0d 00 03 08 3a       	or     $0x3a080300,%eax
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
  4b:	0b 3b                	or     (%ebx),%edi
  4d:	0b 49 13             	or     0x13(%ecx),%ecx
		if(!strcmp(name,".strtab")) {
  50:	38 0b                	cmp    %cl,(%ebx)
  52:	00 00                	add    %al,(%eax)
  54:	07                   	pop    %es
  55:	0d 00 03 0e 3a       	or     $0x3a0e0300,%eax
  5a:	0b 3b                	or     (%ebx),%edi
  5c:	0b 49 13             	or     0x13(%ecx),%ecx
  5f:	38 0b                	cmp    %cl,(%ebx)
  61:	00 00                	add    %al,(%eax)
  63:	08 13                	or     %dl,(%ebx)
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
  65:	01 0b                	add    %ecx,(%ebx)
  67:	0b 3a                	or     (%edx),%edi
  69:	0b 3b                	or     (%ebx),%edi
  6b:	0b 6e 0e             	or     0xe(%esi),%ebp
  6e:	01 13                	add    %edx,(%ebx)
  70:	00 00                	add    %al,(%eax)
  72:	09 0f                	or     %ecx,(%edi)
  74:	00 0b                	add    %cl,(%ebx)
  76:	0b 49 13             	or     0x13(%ecx),%ecx
  79:	00 00                	add    %al,(%eax)
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  7b:	0a 26                	or     (%esi),%ah
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  7d:	00 49 13             	add    %cl,0x13(%ecx)
  80:	00 00                	add    %al,(%eax)
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  82:	0b 0f                	or     (%edi),%ecx
  84:	00 0b                	add    %cl,(%ebx)
  86:	0b 03                	or     (%ebx),%eax
			elf.symtabsz = sh[i].size;
  88:	0e                   	push   %cs
  89:	49                   	dec    %ecx
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  8a:	13 00                	adc    (%eax),%eax
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
  8c:	00 0c 02             	add    %cl,(%edx,%eax,1)
  8f:	01 03                	add    %eax,(%ebx)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  91:	0e                   	push   %cs
  92:	0b 0b                	or     (%ebx),%ecx
  94:	3a 0b                	cmp    (%ebx),%cl
  96:	3b 0b                	cmp    (%ebx),%ecx
  98:	01 13                	add    %edx,(%ebx)
  9a:	00 00                	add    %al,(%eax)
  9c:	0d 04 01 03 0e       	or     $0xe030104,%eax
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
		}
	}
}
  a1:	0b 0b                	or     (%ebx),%ecx
  a3:	3a 0b                	cmp    (%ebx),%cl
  a5:	3b 0b                	cmp    (%ebx),%ecx
  a7:	32 0b                	xor    (%ebx),%cl
  a9:	01 13                	add    %edx,(%ebx)
  ab:	00 00                	add    %al,(%eax)
  ad:	0e                   	push   %cs
  ae:	28 00                	sub    %al,(%eax)

const char* elf_lookupSymbol(uint32_t addr) {
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  b0:	03 0e                	add    (%esi),%ecx
  b2:	1c 0d                	sbb    $0xd,%al
  b4:	00 00                	add    %al,(%eax)
			elf.symtabsz = sh[i].size;
		}
	}
}

const char* elf_lookupSymbol(uint32_t addr) {
  b6:	0f 0d 00             	prefetch (%eax)
  b9:	03 08                	add    (%eax),%ecx
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  bb:	3a 0b                	cmp    (%ebx),%cl
  bd:	3b 0b                	cmp    (%ebx),%ecx
  bf:	49                   	dec    %ecx
  c0:	13 38                	adc    (%eax),%edi
  c2:	0b 32                	or     (%edx),%esi
  c4:	0b 00                	or     (%eax),%eax
  c6:	00 10                	add    %dl,(%eax)
  c8:	0d 00 03 0e 3a       	or     $0x3a0e0300,%eax
  cd:	0b 3b                	or     (%ebx),%edi
  cf:	0b 49 13             	or     0x13(%ecx),%ecx
  d2:	38 0b                	cmp    %cl,(%ebx)
  d4:	32 0b                	xor    (%ebx),%cl
  d6:	00 00                	add    %al,(%eax)
		if(ELF32_ST_TYPE(elf.symtab[i].info) != 0x2) {
  d8:	11 0d 00 03 0e 3a    	adc    %ecx,0x3a0e0300
  de:	0b 3b                	or     (%ebx),%edi
  e0:	0b 49 13             	or     0x13(%ecx),%ecx
			continue;
		}
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
  e3:	3f                   	aas    
  e4:	19 32                	sbb    %esi,(%edx)
  e6:	0b 3c 19             	or     (%ecx,%ebx,1),%edi
  e9:	1c 0b                	sbb    $0xb,%al
  eb:	00 00                	add    %al,(%eax)
  ed:	12 2e                	adc    (%esi),%ch
  ef:	01 3f                	add    %edi,(%edi)
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
  f1:	19 03                	sbb    %eax,(%ebx)
  f3:	0e                   	push   %cs
  f4:	3a 0b                	cmp    (%ebx),%cl
  f6:	3b 0b                	cmp    (%ebx),%ecx
  f8:	32 0b                	xor    (%ebx),%cl
		} 

	}
	return NULL;

}
  fa:	3c 19                	cmp    $0x19,%al
  fc:	64 13 01             	adc    %fs:(%ecx),%eax
  ff:	13 00                	adc    (%eax),%eax
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
		} 

	}
	return NULL;
 101:	00 13                	add    %dl,(%ebx)

}
 103:	05 00 49 13 34       	add    $0x34134900,%eax
 108:	19 00                	sbb    %eax,(%eax)
 10a:	00 14 2e             	add    %dl,(%esi,%ebp,1)
 10d:	01 3f                	add    %edi,(%edi)
 10f:	19 03                	sbb    %eax,(%ebx)

extern "C" uint32_t get_ebp(void);

void elf_printStackTrace()  {
 111:	0e                   	push   %cs
 112:	3a 0b                	cmp    (%ebx),%cl
 114:	3b 0b                	cmp    (%ebx),%ecx
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
 116:	6e                   	outsb  %ds:(%esi),(%dx)
 117:	0e                   	push   %cs
 118:	32 0b                	xor    (%ebx),%cl
	terminal.kprintf("EBP: %x ",*ebp);
 11a:	3c 19                	cmp    $0x19,%al
 11c:	64 13 01             	adc    %fs:(%ecx),%eax

void elf_printStackTrace()  {
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
 11f:	13 00                	adc    (%eax),%eax
	terminal.kprintf("EBP: %x ",*ebp);
 121:	00 15 2e 01 3f 19    	add    %dl,0x193f012e
 127:	03 0e                	add    (%esi),%ecx
 129:	3a 0b                	cmp    (%ebx),%cl
 12b:	3b 0b                	cmp    (%ebx),%ecx
 12d:	6e                   	outsb  %ds:(%esi),(%dx)
 12e:	0e                   	push   %cs
 12f:	49                   	dec    %ecx
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
 130:	13 32                	adc    (%edx),%esi
 132:	0b 3c 19             	or     (%ecx,%ebx,1),%edi
 135:	64 13 01             	adc    %fs:(%ecx),%eax
 138:	13 00                	adc    (%eax),%eax
 13a:	00 16                	add    %dl,(%esi)
 13c:	05 00 49 13 00       	add    $0x134900,%eax
 141:	00 17                	add    %dl,(%edi)
 143:	18 00                	sbb    %al,(%eax)
 145:	00 00                	add    %al,(%eax)
	while (ebp) {
 147:	18 2e                	sbb    %ch,(%esi)
 149:	01 3f                	add    %edi,(%edi)
 14b:	19 03                	sbb    %eax,(%ebx)
 14d:	0e                   	push   %cs
 14e:	3a 0b                	cmp    (%ebx),%cl
		terminal.kprintf("EBP: %x ",*ebp);
 150:	3b 0b                	cmp    (%ebx),%ecx
 152:	6e                   	outsb  %ds:(%esi),(%dx)
 153:	0e                   	push   %cs
 154:	32 0b                	xor    (%ebx),%cl
 156:	3c 19                	cmp    $0x19,%al
 158:	64 13 00             	adc    %fs:(%eax),%eax
 15b:	00 19                	add    %bl,(%ecx)
 15d:	2e 01 3f             	add    %edi,%cs:(%edi)
 160:	19 03                	sbb    %eax,(%ebx)
 162:	0e                   	push   %cs
 163:	3a 0b                	cmp    (%ebx),%cl
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
 165:	3b 0b                	cmp    (%ebx),%ecx
 167:	6e                   	outsb  %ds:(%esi),(%dx)
 168:	0e                   	push   %cs
 169:	11 01                	adc    %eax,(%ecx)
 16b:	12 06                	adc    (%esi),%al
 16d:	40                   	inc    %eax
 16e:	18 97 42 19 01 13    	sbb    %dl,0x13011942(%edi)
 174:	00 00                	add    %al,(%eax)
 176:	1a 05 00 03 0e 3a    	sbb    0x3a0e0300,%al
		ebp = reinterpret_cast<uint32_t*> (*ebp);
 17c:	0b 3b                	or     (%ebx),%edi
 17e:	0b 49 13             	or     0x13(%ecx),%ecx
 181:	02 18                	add    (%eax),%bl
 183:	00 00                	add    %al,(%eax)
 185:	1b 0b                	sbb    (%ebx),%ecx
 187:	01 55 17             	add    %edx,0x17(%ebp)
 18a:	00 00                	add    %al,(%eax)
 18c:	1c 34                	sbb    $0x34,%al
 18e:	00 03                	add    %al,(%ebx)
 190:	08 3a                	or     %bh,(%edx)
 192:	0b 3b                	or     (%ebx),%edi
 194:	0b 49 13             	or     0x13(%ecx),%ecx
 197:	02 17                	add    (%edi),%dl
	}
 199:	00 00                	add    %al,(%eax)
	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
	while (ebp) {
 19b:	1d 34 00 03 0e       	sbb    $0xe030034,%eax
 1a0:	3a 0b                	cmp    (%ebx),%cl
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
		ebp = reinterpret_cast<uint32_t*> (*ebp);
	}
 1a2:	3b 0b                	cmp    (%ebx),%ecx
 1a4:	49                   	dec    %ecx
 1a5:	13 02                	adc    (%edx),%eax
 1a7:	17                   	pop    %ss
 1a8:	00 00                	add    %al,(%eax)
 1aa:	1e                   	push   %ds
 1ab:	89 82 01 00 11 01    	mov    %eax,0x1110001(%edx)
 1b1:	31 13                	xor    %edx,(%ebx)
 1b3:	00 00                	add    %al,(%eax)
 1b5:	1f                   	pop    %ds
 1b6:	2e 01 3f             	add    %edi,%cs:(%edi)
 1b9:	19 03                	sbb    %eax,(%ebx)
 1bb:	0e                   	push   %cs
 1bc:	3a 0b                	cmp    (%ebx),%cl
 1be:	3b 0b                	cmp    (%ebx),%ecx
 1c0:	6e                   	outsb  %ds:(%esi),(%dx)
 1c1:	0e                   	push   %cs
 1c2:	49                   	dec    %ecx
 1c3:	13 11                	adc    (%ecx),%edx
 1c5:	01 12                	add    %edx,(%edx)
 1c7:	06                   	push   %es
 1c8:	40                   	inc    %eax
 1c9:	18 97 42 19 01 13    	sbb    %dl,0x13011942(%edi)
 1cf:	00 00                	add    %al,(%eax)
 1d1:	20 05 00 03 0e 3a    	and    %al,0x3a0e0300
 1d7:	0b 3b                	or     (%ebx),%edi
 1d9:	0b 49 13             	or     0x13(%ecx),%ecx
 1dc:	02 17                	add    (%edi),%dl
 1de:	00 00                	add    %al,(%eax)
 1e0:	21 0b                	and    %ecx,(%ebx)
 1e2:	01 11                	add    %edx,(%ecx)
 1e4:	01 12                	add    %edx,(%edx)
 1e6:	06                   	push   %es
 1e7:	00 00                	add    %al,(%eax)
 1e9:	22 34 00             	and    (%eax,%eax,1),%dh
 1ec:	03 0e                	add    (%esi),%ecx
 1ee:	3a 0b                	cmp    (%ebx),%cl
 1f0:	3b 0b                	cmp    (%ebx),%ecx
 1f2:	49                   	dec    %ecx
 1f3:	13 00                	adc    (%eax),%eax
 1f5:	00 23                	add    %ah,(%ebx)
 1f7:	01 01                	add    %eax,(%ecx)
 1f9:	49                   	dec    %ecx
 1fa:	13 01                	adc    (%ecx),%eax
 1fc:	13 00                	adc    (%eax),%eax
 1fe:	00 24 21             	add    %ah,(%ecx,%eiz,1)
 201:	00 49 13             	add    %cl,0x13(%ecx)
 204:	2f                   	das    
 205:	0b 00                	or     (%eax),%eax
 207:	00 25 34 00 03 0e    	add    %ah,0xe030034
 20d:	3a 0b                	cmp    (%ebx),%cl
 20f:	3b 0b                	cmp    (%ebx),%ecx
 211:	49                   	dec    %ecx
 212:	13 3f                	adc    (%edi),%edi
 214:	19 3c 19             	sbb    %edi,(%ecx,%ebx,1)
 217:	00 00                	add    %al,(%eax)
 219:	26                   	es
 21a:	34 00                	xor    $0x0,%al
 21c:	03 08                	add    (%eax),%ecx
 21e:	3a 0b                	cmp    (%ebx),%cl
 220:	3b 0b                	cmp    (%ebx),%ecx
 222:	49                   	dec    %ecx
 223:	13 3f                	adc    (%edi),%edi
 225:	19 02                	sbb    %eax,(%edx)
 227:	18 00                	sbb    %al,(%eax)
 229:	00 27                	add    %ah,(%edi)
 22b:	2e 01 3f             	add    %edi,%cs:(%edi)
 22e:	19 03                	sbb    %eax,(%ebx)
 230:	0e                   	push   %cs
 231:	3a 0b                	cmp    (%ebx),%cl
 233:	3b 0b                	cmp    (%ebx),%ecx
 235:	6e                   	outsb  %ds:(%esi),(%dx)
 236:	0e                   	push   %cs
 237:	49                   	dec    %ecx
 238:	13 3c 19             	adc    (%ecx,%ebx,1),%edi
 23b:	01 13                	add    %edx,(%ebx)
 23d:	00 00                	add    %al,(%eax)
 23f:	28 2e                	sub    %ch,(%esi)
 241:	00 3f                	add    %bh,(%edi)
 243:	19 03                	sbb    %eax,(%ebx)
 245:	0e                   	push   %cs
 246:	3a 0b                	cmp    (%ebx),%cl
 248:	3b 0b                	cmp    (%ebx),%ecx
 24a:	49                   	dec    %ecx
 24b:	13 3c 19             	adc    (%ecx,%ebx,1),%edi
 24e:	00 00                	add    %al,(%eax)
	...

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	13 00                	adc    (%eax),%eax
   2:	00 00                	add    %al,(%eax)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	1d 00 00 00 01       	sbb    $0x1000000,%eax
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   9:	00 53 1d             	add    %dl,0x1d(%ebx)
   c:	00 00                	add    %al,(%eax)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
   e:	00 29                	add    %ch,(%ecx)
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);
  10:	00 00                	add    %al,(%eax)
  12:	00 02                	add    %al,(%edx)

	uint32_t shstrtab = sh[header->shndx].addr;
  14:	00 77 08             	add    %dh,0x8(%edi)
	...
  1f:	21 00                	and    %eax,(%eax)

	for(uint32_t i = 0; i < header->num; i++) {
  21:	00 00                	add    %al,(%eax)
  23:	23 00                	and    (%eax),%eax
  25:	00 00                	add    %al,(%eax)
  27:	01 00                	add    %eax,(%eax)
  29:	50                   	push   %eax
  2a:	23 00                	and    (%eax),%eax
  2c:	00 00                	add    %al,(%eax)
  2e:	29 00                	sub    %eax,(%eax)
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
  30:	00 00                	add    %al,(%eax)
  32:	0d 00 77 0c 06       	or     $0x60c7700,%eax
			elf.strtabsz = sh[i].size;
  37:	35 1e 33 24 77       	xor    $0x7724331e,%eax
  3c:	08 06                	or     %al,(%esi)
  3e:	22 23                	and    (%ebx),%ah
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  40:	0c 29                	or     $0x29,%al
  42:	00 00                	add    %al,(%eax)
  44:	00 a8 00 00 00 02    	add    %ch,0x2000000(%eax)
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
  4a:	00 91 5c 00 00 00    	add    %dl,0x5c(%ecx)
		if(!strcmp(name,".strtab")) {
  50:	00 00                	add    %al,(%eax)
  52:	00 00                	add    %al,(%eax)
  54:	00 21                	add    %ah,(%ecx)
  56:	00 00                	add    %al,(%eax)
  58:	00 29                	add    %ch,(%ecx)
  5a:	00 00                	add    %al,(%eax)
  5c:	00 02                	add    %al,(%edx)
  5e:	00 30                	add    %dh,(%eax)
  60:	9f                   	lahf   
  61:	29 00                	sub    %eax,(%eax)
  63:	00 00                	add    %al,(%eax)
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
  65:	93                   	xchg   %eax,%ebx
  66:	00 00                	add    %al,(%eax)
  68:	00 01                	add    %al,(%ecx)
  6a:	00 56 00             	add    %dl,0x0(%esi)
  6d:	00 00                	add    %al,(%eax)
  6f:	00 00                	add    %al,(%eax)
  71:	00 00                	add    %al,(%eax)
  73:	00 29                	add    %ch,(%ecx)
  75:	00 00                	add    %al,(%eax)
  77:	00 49 00             	add    %cl,0x0(%ecx)
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  7a:	00 00                	add    %al,(%eax)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  7c:	01 00                	add    %eax,(%eax)
  7e:	55                   	push   %ebp
  7f:	50                   	push   %eax
  80:	00 00                	add    %al,(%eax)
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  82:	00 93 00 00 00 01    	add    %dl,0x1000000(%ebx)
			elf.symtabsz = sh[i].size;
  88:	00 55 00             	add    %dl,0x0(%ebp)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  8b:	00 00                	add    %al,(%eax)
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
  8d:	00 00                	add    %al,(%eax)
  8f:	00 00                	add    %al,(%eax)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  91:	00 b0 00 00 00 fb    	add    %dh,-0x5000000(%eax)
  97:	00 00                	add    %al,(%eax)
  99:	00 02                	add    %al,(%edx)
  9b:	00 91 00 fb 00 00    	add    %dl,0xfb00(%ecx)
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
		}
	}
}
  a1:	00 03                	add    %al,(%ebx)
  a3:	01 00                	add    %eax,(%eax)
  a5:	00 01                	add    %al,(%ecx)
  a7:	00 53 03             	add    %dl,0x3(%ebx)
  aa:	01 00                	add    %eax,(%eax)
  ac:	00 04 01             	add    %al,(%ecx,%eax,1)
  af:	00 00                	add    %al,(%eax)

const char* elf_lookupSymbol(uint32_t addr) {
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  b1:	02 00                	add    (%eax),%al
  b3:	91                   	xchg   %eax,%ecx
	...
  bc:	00 b0 00 00 00 ce    	add    %dh,-0x32000000(%eax)
  c2:	00 00                	add    %al,(%eax)
  c4:	00 02                	add    %al,(%edx)
  c6:	00 30                	add    %dh,(%eax)
  c8:	9f                   	lahf   
	...
  d1:	21 01                	and    %eax,(%ecx)
  d3:	00 00                	add    %al,(%eax)
  d5:	2f                   	das    
  d6:	01 00                	add    %eax,(%eax)
		if(ELF32_ST_TYPE(elf.symtab[i].info) != 0x2) {
  d8:	00 01                	add    %al,(%ecx)
  da:	00 50 2f             	add    %dl,0x2f(%eax)
  dd:	01 00                	add    %eax,(%eax)
  df:	00 35 01 00 00 01    	add    %dh,0x1000001
			continue;
		}
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
  e5:	00 56 35             	add    %dl,0x35(%esi)
  e8:	01 00                	add    %eax,(%eax)
  ea:	00 a5 01 00 00 01    	add    %ah,0x1000001(%ebp)
  f0:	00 53 00             	add    %dl,0x0(%ebx)
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
  f3:	00 00                	add    %al,(%eax)
  f5:	00 00                	add    %al,(%eax)
  f7:	00 00                	add    %al,(%eax)
		} 

	}
	return NULL;

}
  f9:	00 30                	add    %dh,(%eax)
  fb:	01 00                	add    %eax,(%eax)
  fd:	00 4e 01             	add    %cl,0x1(%esi)
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
		} 

	}
	return NULL;
 100:	00 00                	add    %al,(%eax)

}
 102:	03 00                	add    (%eax),%eax
 104:	76 04                	jbe    10a <.debug_loc+0x10a>
 106:	9f                   	lahf   
 107:	64 01 00             	add    %eax,%fs:(%eax)
 10a:	00 9a 01 00 00 03    	add    %bl,0x3000001(%edx)

extern "C" uint32_t get_ebp(void);

void elf_printStackTrace()  {
 110:	00 73 04             	add    %dh,0x4(%ebx)
 113:	9f                   	lahf   
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	1c 00                	sbb    $0x0,%al
   2:	00 00                	add    %al,(%eax)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	02 00                	add    (%eax),%al
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   6:	00 00                	add    %al,(%eax)
   8:	00 00                	add    %al,(%eax)
   a:	04 00                	add    $0x0,%al
	...
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
  14:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
  15:	01 00                	add    %eax,(%eax)
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	04 00                	add    $0x0,%al
   2:	00 00                	add    %al,(%eax)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	06                   	push   %es
   5:	00 00                	add    %al,(%eax)
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   7:	00 0d 00 00 00 a0    	add    %cl,0xa0000000
	...
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
  15:	00 00                	add    %al,(%eax)
  17:	00 04 00             	add    %al,(%eax,%eax,1)
  1a:	00 00                	add    %al,(%eax)
  1c:	06                   	push   %es
  1d:	00 00                	add    %al,(%eax)
  1f:	00 21                	add    %ah,(%ecx)

	for(uint32_t i = 0; i < header->num; i++) {
  21:	00 00                	add    %al,(%eax)
  23:	00 a0 00 00 00 00    	add    %ah,0x0(%eax)
  29:	00 00                	add    %al,(%eax)
  2b:	00 00                	add    %al,(%eax)
  2d:	00 00                	add    %al,(%eax)
  2f:	00 30                	add    %dh,(%eax)
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
  31:	00 00                	add    %al,(%eax)
  33:	00 3f                	add    %bh,(%edi)
  35:	00 00                	add    %al,(%eax)
			elf.strtabsz = sh[i].size;
  37:	00 49 00             	add    %cl,0x0(%ecx)
  3a:	00 00                	add    %al,(%eax)
  3c:	7c 00                	jl     3e <.debug_ranges+0x3e>
  3e:	00 00                	add    %al,(%eax)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  40:	82                   	(bad)  
  41:	00 00                	add    %al,(%eax)
  43:	00 8a 00 00 00 8c    	add    %cl,-0x74000000(%edx)
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
  49:	00 00                	add    %al,(%eax)
  4b:	00 91 00 00 00 00    	add    %dl,0x0(%ecx)
		if(!strcmp(name,".strtab")) {
  51:	00 00                	add    %al,(%eax)
  53:	00 00                	add    %al,(%eax)
  55:	00 00                	add    %al,(%eax)
  57:	00 b0 00 00 00 b6    	add    %dh,-0x4a000000(%eax)
  5d:	00 00                	add    %al,(%eax)
  5f:	00 bb 00 00 00 f9    	add    %bh,-0x7000000(%ebx)
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	7d 01                	jge    3 <.debug_line+0x3>
   2:	00 00                	add    %al,(%eax)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	02 00                	add    (%eax),%al
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   6:	1a 01                	sbb    (%ecx),%al
   8:	00 00                	add    %al,(%eax)
   a:	01 01                	add    %eax,(%ecx)
   c:	fb                   	sti    
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
   d:	0e                   	push   %cs
   e:	0d 00 01 01 01       	or     $0x1010100,%eax
  13:	01 00                	add    %eax,(%eax)
  15:	00 00                	add    %al,(%eax)
  17:	01 00                	add    %eax,(%eax)
  19:	00 01                	add    %al,(%ecx)
  1b:	73 72                	jae    8f <.debug_line+0x8f>
  1d:	63 2f                	arpl   %bp,(%edi)
  1f:	6d                   	insl   (%dx),%es:(%edi)
  20:	6f                   	outsl  %ds:(%esi),(%dx)

	for(uint32_t i = 0; i < header->num; i++) {
  21:	64                   	fs
  22:	75 6c                	jne    90 <.debug_line+0x90>
  24:	65                   	gs
  25:	73 00                	jae    27 <.debug_line+0x27>
  27:	2f                   	das    
  28:	68 6f 6d 65 2f       	push   $0x2f656d6f
  2d:	6d                   	insl   (%dx),%es:(%edi)
  2e:	61                   	popa   
  2f:	6b 65 72 69          	imul   $0x69,0x72(%ebp),%esp
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
  33:	6d                   	insl   (%dx),%es:(%edi)
  34:	61                   	popa   
  35:	67                   	addr16
  36:	65                   	gs
			elf.strtabsz = sh[i].size;
  37:	73 2f                	jae    68 <.debug_line+0x68>
  39:	4f                   	dec    %edi
  3a:	53                   	push   %ebx
  3b:	5a                   	pop    %edx
  3c:	69 6e 2f 63 72 6f 73 	imul   $0x736f7263,0x2f(%esi),%ebp
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  43:	73 2f                	jae    74 <.debug_line+0x74>
  45:	6c                   	insb   (%dx),%es:(%edi)
  46:	69 62 2f 67 63 63 2f 	imul   $0x2f636367,0x2f(%edx),%esp
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
  4d:	69 36 38 36 2d 65    	imul   $0x652d3638,(%esi),%esi
		if(!strcmp(name,".strtab")) {
  53:	6c                   	insb   (%dx),%es:(%edi)
  54:	66                   	data16
  55:	2f                   	das    
  56:	34 2e                	xor    $0x2e,%al
  58:	39 2e                	cmp    %ebp,(%esi)
  5a:	32 2f                	xor    (%edi),%ch
  5c:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
  63:	00 69 6e             	add    %ch,0x6e(%ecx)
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
  66:	63 6c 75 64          	arpl   %bp,0x64(%ebp,%esi,2)
  6a:	65                   	gs
  6b:	2f                   	das    
  6c:	6d                   	insl   (%dx),%es:(%edi)
  6d:	6f                   	outsl  %ds:(%esi),(%dx)
  6e:	64                   	fs
  6f:	75 6c                	jne    dd <.debug_line+0xdd>
  71:	65                   	gs
  72:	73 00                	jae    74 <.debug_line+0x74>
  74:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  7b:	2f                   	das    
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  7c:	64                   	fs
  7d:	72 69                	jb     e8 <.debug_line+0xe8>
  7f:	76 65                	jbe    e6 <.debug_line+0xe6>
  81:	72 73                	jb     f6 <.debug_line+0xf6>
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  83:	00 69 6e             	add    %ch,0x6e(%ecx)
  86:	63 6c 75 64          	arpl   %bp,0x64(%ebp,%esi,2)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  8a:	65                   	gs
  8b:	2f                   	das    
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
  8c:	6c                   	insb   (%dx),%es:(%edi)
  8d:	69 62 63 00 69 6e 63 	imul   $0x636e6900,0x63(%edx),%esp
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  94:	6c                   	insb   (%dx),%es:(%edi)
  95:	75 64                	jne    fb <.debug_line+0xfb>
  97:	65                   	gs
  98:	2f                   	das    
  99:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
  9d:	65                   	gs
  9e:	6c                   	insb   (%dx),%es:(%edi)
  9f:	00 00                	add    %al,(%eax)
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
		}
	}
}
  a1:	45                   	inc    %ebp
  a2:	6c                   	insb   (%dx),%es:(%edi)
  a3:	66                   	data16
  a4:	2e 63 70 70          	arpl   %si,%cs:0x70(%eax)
  a8:	00 01                	add    %al,(%ecx)
  aa:	00 00                	add    %al,(%eax)
  ac:	73 74                	jae    122 <.debug_line+0x122>
  ae:	64 69 6e 74 2d 67 63 	imul   $0x6363672d,%fs:0x74(%esi),%ebp
  b5:	63 

const char* elf_lookupSymbol(uint32_t addr) {
  b6:	2e                   	cs
  b7:	68 00 02 00 00       	push   $0x200
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  bc:	4d                   	dec    %ebp
  bd:	75 6c                	jne    12b <.debug_line+0x12b>
  bf:	74 69                	je     12a <.debug_line+0x12a>
  c1:	62 6f 6f             	bound  %ebp,0x6f(%edi)
  c4:	74 2e                	je     f4 <.debug_line+0xf4>
  c6:	68 70 70 00 03       	push   $0x3007070
  cb:	00 00                	add    %al,(%eax)
  cd:	45                   	inc    %ebp
  ce:	6c                   	insb   (%dx),%es:(%edi)
  cf:	66                   	data16
  d0:	2e                   	cs
  d1:	68 70 70 00 03       	push   $0x3007070
  d6:	00 00                	add    %al,(%eax)
		if(ELF32_ST_TYPE(elf.symtab[i].info) != 0x2) {
  d8:	73 74                	jae    14e <.debug_line+0x14e>
  da:	64                   	fs
  db:	64                   	fs
  dc:	65                   	gs
  dd:	66                   	data16
  de:	2e                   	cs
  df:	68 00 02 00 00       	push   $0x200
			continue;
		}
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
  e4:	73 74                	jae    15a <.debug_line+0x15a>
  e6:	64                   	fs
  e7:	61                   	popa   
  e8:	72 67                	jb     151 <.debug_line+0x151>
  ea:	2e                   	cs
  eb:	68 00 02 00 00       	push   $0x200
  f0:	54                   	push   %esp
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
  f1:	65                   	gs
  f2:	72 6d                	jb     161 <.debug_line+0x161>
  f4:	69 6e 61 6c 2e 68 70 	imul   $0x70682e6c,0x61(%esi),%ebp
		} 

	}
	return NULL;

}
  fb:	70 00                	jo     fd <.debug_line+0xfd>
  fd:	04 00                	add    $0x0,%al
  ff:	00 53 74             	add    %dl,0x74(%ebx)
 102:	72 69                	jb     16d <.debug_line+0x16d>
 104:	6e                   	outsb  %ds:(%esi),(%dx)
 105:	67                   	addr16
 106:	2e                   	cs
 107:	68 70 70 00 05       	push   $0x5007070
 10c:	00 00                	add    %al,(%eax)
 10e:	4b                   	dec    %ebx
 10f:	65                   	gs

extern "C" uint32_t get_ebp(void);

void elf_printStackTrace()  {
 110:	72 6e                	jb     180 <.debug_line+0x180>
 112:	65                   	gs
 113:	6c                   	insb   (%dx),%es:(%edi)
 114:	47                   	inc    %edi
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
 115:	6c                   	insb   (%dx),%es:(%edi)
 116:	6f                   	outsl  %ds:(%esi),(%dx)
 117:	62 61 6c             	bound  %esp,0x6c(%ecx)
	terminal.kprintf("EBP: %x ",*ebp);
 11a:	73 2e                	jae    14a <.debug_line+0x14a>
 11c:	68 70 70 00 06       	push   $0x6007070
 121:	00 00                	add    %al,(%eax)
 123:	00 00                	add    %al,(%eax)
 125:	05 02 00 00 00       	add    $0x2,%eax
 12a:	00 18                	add    %bl,(%eax)
 12c:	4f                   	dec    %edi
 12d:	29 3c 4d 3a 3e d8 e7 	sub    %edi,-0x1827c1c6(,%ecx,2)
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
 134:	75 00                	jne    136 <.debug_line+0x136>
	terminal.kprintf("EBP: %x ",*ebp);
 136:	02 04 02             	add    (%edx,%eax,1),%al
 139:	7e 9f                	jle    da <.debug_line+0xda>
 13b:	75 08                	jne    145 <.debug_line+0x145>
 13d:	4d                   	dec    %ebp
 13e:	08 4b 03             	or     %cl,0x3(%ebx)
 141:	7a 2e                	jp     171 <.debug_line+0x171>
 143:	6c                   	insb   (%dx),%es:(%edi)
 144:	59                   	pop    %ecx
 145:	03 79 3c             	add    0x3c(%ecx),%edi
	while (ebp) {
 148:	35 03 79 58 03       	xor    $0x3587903,%eax
 14d:	0a e4                	or     %ah,%ah
 14f:	f4                   	hlt    
		terminal.kprintf("EBP: %x ",*ebp);
 150:	13 65 20             	adc    0x20(%ebp),%esp
 153:	4b                   	dec    %ebx
 154:	00 02                	add    %al,(%edx)
 156:	04 02                	add    $0x2,%al
 158:	06                   	push   %es
 159:	08 74 06 4b          	or     %dh,0x4b(%esi,%eax,1)
 15d:	bd 00 02 04 01       	mov    $0x1040200,%ebp
 162:	06                   	push   %es
 163:	74 06                	je     16b <.debug_line+0x16b>
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
 165:	75 88                	jne    ef <.debug_line+0xef>
 167:	72 30                	jb     199 <_Z19elf_printStackTracev+0x89>
 169:	da 5c 59 57          	ficompl 0x57(%ecx,%ebx,2)
 16d:	2f                   	das    
 16e:	e7 3b                	out    %eax,$0x3b
 170:	2f                   	das    
 171:	08 21                	or     %ah,(%ecx)
 173:	91                   	xchg   %eax,%ecx
 174:	08 3e                	or     %bh,(%esi)
 176:	08 4b 08             	or     %cl,0x8(%ebx)
		ebp = reinterpret_cast<uint32_t*> (*ebp);
 179:	d7                   	xlat   %ds:(%ebx)
 17a:	29 7b 02             	sub    %edi,0x2(%ebx)
 17d:	06                   	push   %es
 17e:	00 01                	add    %al,(%ecx)
 180:	01                   	.byte 0x1

Disassembly of section .debug_str:

00000000 <.debug_str>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	43                   	inc    %ebx
   1:	4f                   	dec    %edi
   2:	4c                   	dec    %esp
   3:	4f                   	dec    %edi
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	52                   	push   %edx
   5:	5f                   	pop    %edi
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   6:	52                   	push   %edx
   7:	45                   	inc    %ebp
   8:	44                   	inc    %esp
   9:	00 5f 5a             	add    %bl,0x5a(%edi)
   c:	31 39                	xor    %edi,(%ecx)
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
   e:	65                   	gs
   f:	6c                   	insb   (%dx),%es:(%edi)
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);
  10:	66 5f                	pop    %di
  12:	70 72                	jo     86 <.debug_str+0x86>

	uint32_t shstrtab = sh[header->shndx].addr;
  14:	69 6e 74 53 74 61 63 	imul   $0x63617453,0x74(%esi),%ebp
  1b:	6b 54 72 61 63       	imul   $0x63,0x61(%edx,%esi,2),%edx
  20:	65                   	gs

	for(uint32_t i = 0; i < header->num; i++) {
  21:	76 00                	jbe    23 <.debug_str+0x23>
  23:	5f                   	pop    %edi
  24:	5a                   	pop    %edx
  25:	4e                   	dec    %esi
  26:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
  2a:	6d                   	insl   (%dx),%es:(%edi)
  2b:	69 6e 61 6c 37 70 75 	imul   $0x7570376c,0x61(%esi),%ebp
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
  32:	74 63                	je     97 <.debug_str+0x97>
  34:	68 61 72 45 63       	push   $0x63457261
			elf.strtabsz = sh[i].size;
  39:	00 70 72             	add    %dh,0x72(%eax)
  3c:	69 6e 74 00 73 65 74 	imul   $0x74657300,0x74(%esi),%ebp
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  43:	43                   	inc    %ebx
  44:	6f                   	outsl  %ds:(%esi),(%dx)
  45:	6c                   	insb   (%dx),%es:(%edi)
  46:	6f                   	outsl  %ds:(%esi),(%dx)
  47:	72 00                	jb     49 <.debug_str+0x49>
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
  49:	43                   	inc    %ebx
  4a:	4f                   	dec    %edi
  4b:	4c                   	dec    %esp
  4c:	4f                   	dec    %edi
  4d:	52                   	push   %edx
  4e:	5f                   	pop    %edi
  4f:	4c                   	dec    %esp
		if(!strcmp(name,".strtab")) {
  50:	49                   	dec    %ecx
  51:	47                   	inc    %edi
  52:	48                   	dec    %eax
  53:	54                   	push   %esp
  54:	5f                   	pop    %edi
  55:	52                   	push   %edx
  56:	45                   	inc    %ebp
  57:	44                   	inc    %esp
  58:	00 73 69             	add    %dh,0x69(%ebx)
  5b:	7a 65                	jp     c2 <.debug_str+0xc2>
  5d:	5f                   	pop    %edi
  5e:	74 00                	je     60 <.debug_str+0x60>
  60:	73 79                	jae    db <.debug_str+0xdb>
  62:	6d                   	insl   (%dx),%es:(%edi)
  63:	74 61                	je     c6 <.debug_str+0xc6>
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
  65:	62 00                	bound  %eax,(%eax)
  67:	76 61                	jbe    ca <.debug_str+0xca>
  69:	5f                   	pop    %edi
  6a:	6c                   	insb   (%dx),%es:(%edi)
  6b:	69 73 74 00 74 79 70 	imul   $0x70797400,0x74(%ebx),%esi
  72:	65 00 6c 6f 6e       	add    %ch,%gs:0x6e(%edi,%ebp,2)
  77:	67 20 6c 6f          	and    %ch,0x6f(%si)
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  7b:	6e                   	outsb  %ds:(%esi),(%dx)
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  7c:	67 20 75 6e          	and    %dh,0x6e(%di)
  80:	73 69                	jae    eb <.debug_str+0xeb>
		const char* name = reinterpret_cast<const char*>(shstrtab + sh[i].name);
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
  82:	67 6e                	outsb  %ds:(%si),(%dx)
  84:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
			elf.symtabsz = sh[i].size;
  89:	74 00                	je     8b <.debug_str+0x8b>
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  8b:	73 68                	jae    f5 <.debug_str+0xf5>
		if(!strcmp(name,".strtab")) {
			elf.strtab = reinterpret_cast<const char*> (sh[i].addr);
			elf.strtabsz = sh[i].size;
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
  8d:	6e                   	outsb  %ds:(%esi),(%dx)
  8e:	64                   	fs
  8f:	78 00                	js     91 <.debug_str+0x91>
void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
  91:	61                   	popa   
  92:	64                   	fs
  93:	64                   	fs
  94:	72 00                	jb     96 <.debug_str+0x96>
  96:	43                   	inc    %ebx
  97:	4f                   	dec    %edi
  98:	4c                   	dec    %esp
  99:	4f                   	dec    %edi
  9a:	52                   	push   %edx
  9b:	5f                   	pop    %edi
  9c:	4c                   	dec    %esp
  9d:	49                   	dec    %ecx
  9e:	47                   	inc    %edi
  9f:	48                   	dec    %eax
		} else if(!strcmp(name,".symtab")) {
			elf.symtab = reinterpret_cast<elf_symbol_t*> (sh[i].addr);
			elf.symtabsz = sh[i].size;
		}
	}
}
  a0:	54                   	push   %esp
  a1:	5f                   	pop    %edi
  a2:	42                   	inc    %edx
  a3:	52                   	push   %edx
  a4:	4f                   	dec    %edi
  a5:	57                   	push   %edi
  a6:	4e                   	dec    %esi
  a7:	00 43 4f             	add    %al,0x4f(%ebx)
  aa:	4c                   	dec    %esp
  ab:	4f                   	dec    %edi
  ac:	52                   	push   %edx
  ad:	5f                   	pop    %edi
  ae:	57                   	push   %edi
  af:	48                   	dec    %eax

const char* elf_lookupSymbol(uint32_t addr) {
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  b0:	49                   	dec    %ecx
  b1:	54                   	push   %esp
  b2:	45                   	inc    %ebp
  b3:	00 43 4f             	add    %al,0x4f(%ebx)
			elf.symtabsz = sh[i].size;
		}
	}
}

const char* elf_lookupSymbol(uint32_t addr) {
  b6:	4c                   	dec    %esp
  b7:	4f                   	dec    %edi
  b8:	52                   	push   %edx
  b9:	5f                   	pop    %edi
  ba:	4c                   	dec    %esp
	for(uint32_t i = 0; i< (elf.symtabsz/sizeof(elf_symbol_t)); i++) {
  bb:	49                   	dec    %ecx
  bc:	47                   	inc    %edi
  bd:	48                   	dec    %eax
  be:	54                   	push   %esp
  bf:	5f                   	pop    %edi
  c0:	4d                   	dec    %ebp
  c1:	41                   	inc    %ecx
  c2:	47                   	inc    %edi
  c3:	45                   	inc    %ebp
  c4:	4e                   	dec    %esi
  c5:	54                   	push   %esp
  c6:	41                   	inc    %ecx
  c7:	00 65 6e             	add    %ah,0x6e(%ebp)
  ca:	74 73                	je     13f <.debug_str+0x13f>
  cc:	69 7a 65 00 43 4f 4c 	imul   $0x4c4f4300,0x65(%edx),%edi
  d3:	4f                   	dec    %edi
  d4:	52                   	push   %edx
  d5:	5f                   	pop    %edi
  d6:	42                   	inc    %edx
		if(ELF32_ST_TYPE(elf.symtab[i].info) != 0x2) {
  d7:	52                   	push   %edx
  d8:	4f                   	dec    %edi
  d9:	57                   	push   %edi
  da:	4e                   	dec    %esi
  db:	00 6c 6f 6e          	add    %ch,0x6e(%edi,%ebp,2)
  df:	67 20 6c 6f          	and    %ch,0x6f(%si)
			continue;
		}
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
  e3:	6e                   	outsb  %ds:(%esi),(%dx)
  e4:	67 20 69 6e          	and    %ch,0x6e(%bx,%di)
  e8:	74 00                	je     ea <.debug_str+0xea>
  ea:	73 69                	jae    155 <.debug_str+0x155>
  ec:	67 6e                	outsb  %ds:(%si),(%dx)
  ee:	65 64 20 63 68       	gs and %ah,%fs:%gs:0x68(%ebx)
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
  f3:	61                   	popa   
  f4:	72 00                	jb     f6 <.debug_str+0xf6>
  f6:	6f                   	outsl  %ds:(%esi),(%dx)
  f7:	74 68                	je     161 <.debug_str+0x161>
		} 

	}
	return NULL;

}
  f9:	65                   	gs
  fa:	72 00                	jb     fc <.debug_str+0xfc>
  fc:	43                   	inc    %ebx
  fd:	4f                   	dec    %edi
  fe:	4c                   	dec    %esp
  ff:	4f                   	dec    %edi
		if((addr >= elf.symtab[i].value) && (addr < (elf.symtab[i].value + elf.symtab[i].size))) {
			return reinterpret_cast<const char*>(reinterpret_cast<uint32_t>(elf.strtab) + elf.symtab[i].name);
		} 

	}
	return NULL;
 100:	52                   	push   %edx
 101:	5f                   	pop    %edi

}
 102:	44                   	inc    %esp
 103:	41                   	inc    %ecx
 104:	52                   	push   %edx
 105:	4b                   	dec    %ebx
 106:	5f                   	pop    %edi
 107:	47                   	inc    %edi
 108:	52                   	push   %edx
 109:	45                   	inc    %ebp
 10a:	59                   	pop    %ecx
 10b:	00 5f 5a             	add    %bl,0x5a(%edi)
 10e:	4e                   	dec    %esi
 10f:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)

extern "C" uint32_t get_ebp(void);

void elf_printStackTrace()  {
 113:	6d                   	insl   (%dx),%es:(%edi)
 114:	69 6e 61 6c 31 32 73 	imul   $0x7332316c,0x61(%esi),%ebp
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
 11b:	65                   	gs
 11c:	74 43                	je     161 <.debug_str+0x161>
 11e:	75 72                	jne    192 <.debug_str+0x192>

void elf_printStackTrace()  {
	uint32_t *ebp, *eip;
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
 120:	73 6f                	jae    191 <.debug_str+0x191>
	terminal.kprintf("EBP: %x ",*ebp);
 122:	72 50                	jb     174 <.debug_str+0x174>
 124:	6f                   	outsl  %ds:(%esi),(%dx)
 125:	73 45                	jae    16c <.debug_str+0x16c>
 127:	6d                   	insl   (%dx),%es:(%edi)
 128:	6d                   	insl   (%dx),%es:(%edi)
 129:	00 6c 6f 6e          	add    %ch,0x6e(%edi,%ebp,2)
 12d:	67 20 69 6e          	and    %ch,0x6e(%bx,%di)
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
 131:	74 00                	je     133 <.debug_str+0x133>
	char buffer[65];

	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
 133:	2f                   	das    
 134:	68 6f 6d 65 2f       	push   $0x2f656d6f
	terminal.kprintf("EBP: %x ",*ebp);
 139:	6d                   	insl   (%dx),%es:(%edi)
 13a:	61                   	popa   
 13b:	6b 65 72 69          	imul   $0x69,0x72(%ebp),%esp
 13f:	6d                   	insl   (%dx),%es:(%edi)
 140:	61                   	popa   
 141:	67                   	addr16
 142:	65                   	gs
 143:	73 2f                	jae    174 <.debug_str+0x174>
 145:	4f                   	dec    %edi
 146:	53                   	push   %ebx
	while (ebp) {
 147:	5a                   	pop    %edx
 148:	69 6e 00 5f 5f 62 75 	imul   $0x75625f5f,0x0(%esi),%ebp
 14f:	69 6c 74 69 6e 5f 76 	imul   $0x61765f6e,0x69(%esp,%esi,2),%ebp
 156:	61 
		terminal.kprintf("EBP: %x ",*ebp);
 157:	5f                   	pop    %edi
 158:	6c                   	insb   (%dx),%es:(%edi)
 159:	69 73 74 00 6d 75 6c 	imul   $0x6c756d00,0x74(%ebx),%esi
 160:	74 69                	je     1cb <.debug_str+0x1cb>
 162:	62 6f 6f             	bound  %ebp,0x6f(%edi)
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
 165:	74 5f                	je     1c6 <.debug_str+0x1c6>
 167:	65                   	gs
 168:	6c                   	insb   (%dx),%es:(%edi)
 169:	66 5f                	pop    %di
 16b:	73 65                	jae    1d2 <.debug_str+0x1d2>
 16d:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
 171:	6e                   	outsb  %ds:(%esi),(%dx)
 172:	5f                   	pop    %edi
 173:	68 65 61 64 65       	push   $0x65646165
 178:	72 5f                	jb     1d9 <.debug_str+0x1d9>
		ebp = reinterpret_cast<uint32_t*> (*ebp);
 17a:	74 61                	je     1dd <.debug_str+0x1dd>
 17c:	62 6c 65 00          	bound  %ebp,0x0(%ebp,%eiz,2)
 180:	70 75                	jo     1f7 <.debug_str+0x1f7>
 182:	74 63                	je     1e7 <.debug_str+0x1e7>
 184:	68 61 72 00 75       	push   $0x75007261
 189:	69 6e 74 31 36 5f 74 	imul   $0x745f3631,0x74(%esi),%ebp
 190:	00 73 65             	add    %dh,0x65(%ebx)
 193:	74 43                	je     1d8 <.debug_str+0x1d8>
 195:	75 72                	jne    209 <.debug_str+0x209>
 197:	73 6f                	jae    208 <.debug_str+0x208>
	}
 199:	72 50                	jb     1eb <.debug_str+0x1eb>
	ebp = reinterpret_cast<uint32_t*>(get_ebp());
	terminal.kprintf("EBP: %x ",*ebp);
	eip = ebp+1;
	ebp = reinterpret_cast<uint32_t*> (*ebp);
	terminal.kprintf("EBP: %x ",*ebp);
	while (ebp) {
 19b:	6f                   	outsl  %ds:(%esi),(%dx)
 19c:	73 00                	jae    19e <.debug_str+0x19e>
 19e:	5f                   	pop    %edi
 19f:	5a                   	pop    %edx
 1a0:	4e                   	dec    %esi
		eip = ebp +1;
		terminal.kprintf(" [0x%x] %s \n",*eip,elf_lookupSymbol(*eip));
		ebp = reinterpret_cast<uint32_t*> (*ebp);
	}
 1a1:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 1a5:	6d                   	insl   (%dx),%es:(%edi)
 1a6:	69 6e 61 6c 31 30 72 	imul   $0x7230316c,0x61(%esi),%ebp
 1ad:	65                   	gs
 1ae:	73 65                	jae    215 <.debug_str+0x215>
 1b0:	74 43                	je     1f5 <.debug_str+0x1f5>
 1b2:	6f                   	outsl  %ds:(%esi),(%dx)
 1b3:	6c                   	insb   (%dx),%es:(%edi)
 1b4:	6f                   	outsl  %ds:(%esi),(%dx)
 1b5:	72 45                	jb     1fc <.debug_str+0x1fc>
 1b7:	76 00                	jbe    1b9 <.debug_str+0x1b9>
 1b9:	43                   	inc    %ebx
 1ba:	4f                   	dec    %edi
 1bb:	4c                   	dec    %esp
 1bc:	4f                   	dec    %edi
 1bd:	52                   	push   %edx
 1be:	5f                   	pop    %edi
 1bf:	4c                   	dec    %esp
 1c0:	49                   	dec    %ecx
 1c1:	47                   	inc    %edi
 1c2:	48                   	dec    %eax
 1c3:	54                   	push   %esp
 1c4:	5f                   	pop    %edi
 1c5:	47                   	inc    %edi
 1c6:	52                   	push   %edx
 1c7:	45                   	inc    %ebp
 1c8:	59                   	pop    %ecx
 1c9:	00 43 4f             	add    %al,0x4f(%ebx)
 1cc:	4c                   	dec    %esp
 1cd:	4f                   	dec    %edi
 1ce:	52                   	push   %edx
 1cf:	5f                   	pop    %edi
 1d0:	4d                   	dec    %ebp
 1d1:	41                   	inc    %ecx
 1d2:	47                   	inc    %edi
 1d3:	45                   	inc    %ebp
 1d4:	4e                   	dec    %esi
 1d5:	54                   	push   %esp
 1d6:	41                   	inc    %ecx
 1d7:	00 6b 70             	add    %ch,0x70(%ebx)
 1da:	75 74                	jne    250 <.debug_str+0x250>
 1dc:	73 5f                	jae    23d <.debug_str+0x23d>
 1de:	00 5f 5a             	add    %bl,0x5a(%edi)
 1e1:	4e                   	dec    %esi
 1e2:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 1e6:	6d                   	insl   (%dx),%es:(%edi)
 1e7:	69 6e 61 6c 35 70 72 	imul   $0x7270356c,0x61(%esi),%ebp
 1ee:	69 6e 74 45 50 4b 63 	imul   $0x634b5045,0x74(%esi),%ebp
 1f5:	00 6c 69 6e          	add    %ch,0x6e(%ecx,%ebp,2)
 1f9:	6b 00 74             	imul   $0x74,(%eax),%eax
 1fc:	65                   	gs
 1fd:	72 6d                	jb     26c <.debug_str+0x26c>
 1ff:	69 6e 61 6c 00 54 65 	imul   $0x6554006c,0x61(%esi),%ebp
 206:	72 6d                	jb     275 <.debug_str+0x275>
 208:	69 6e 61 6c 00 65 6c 	imul   $0x6c65006c,0x61(%esi),%ebp
 20f:	66 5f                	pop    %di
 211:	73 79                	jae    28c <.debug_str+0x28c>
 213:	6d                   	insl   (%dx),%es:(%edi)
 214:	62 6f 6c             	bound  %ebp,0x6c(%edi)
 217:	5f                   	pop    %edi
 218:	74 00                	je     21a <.debug_str+0x21a>
 21a:	76 61                	jbe    27d <.debug_str+0x27d>
 21c:	6c                   	insb   (%dx),%es:(%edi)
 21d:	75 65                	jne    284 <.debug_str+0x284>
 21f:	00 31                	add    %dh,(%ecx)
 221:	39 65 6c             	cmp    %esp,0x6c(%ebp)
 224:	66 5f                	pop    %di
 226:	73 65                	jae    28d <.debug_str+0x28d>
 228:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
 22c:	6e                   	outsb  %ds:(%esi),(%dx)
 22d:	48                   	dec    %eax
 22e:	65                   	gs
 22f:	61                   	popa   
 230:	64                   	fs
 231:	65                   	gs
 232:	72 5f                	jb     293 <.debug_str+0x293>
 234:	74 00                	je     236 <.debug_str+0x236>
 236:	75 6e                	jne    2a6 <.debug_str+0x2a6>
 238:	73 69                	jae    2a3 <.debug_str+0x2a3>
 23a:	67 6e                	outsb  %ds:(%si),(%dx)
 23c:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 241:	74 00                	je     243 <.debug_str+0x243>
 243:	65                   	gs
 244:	6c                   	insb   (%dx),%es:(%edi)
 245:	66 5f                	pop    %di
 247:	74 00                	je     249 <.debug_str+0x249>
 249:	5f                   	pop    %edi
 24a:	5a                   	pop    %edx
 24b:	38 65 6c             	cmp    %ah,0x6c(%ebp)
 24e:	66 5f                	pop    %di
 250:	69 6e 69 74 50 33 34 	imul   $0x34335074,0x69(%esi),%ebp
 257:	6d                   	insl   (%dx),%es:(%edi)
 258:	75 6c                	jne    2c6 <.debug_str+0x2c6>
 25a:	74 69                	je     2c5 <.debug_str+0x2c5>
 25c:	62 6f 6f             	bound  %ebp,0x6f(%edi)
 25f:	74 5f                	je     2c0 <.debug_str+0x2c0>
 261:	65                   	gs
 262:	6c                   	insb   (%dx),%es:(%edi)
 263:	66 5f                	pop    %di
 265:	73 65                	jae    2cc <.debug_str+0x2cc>
 267:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
 26b:	6e                   	outsb  %ds:(%esi),(%dx)
 26c:	5f                   	pop    %edi
 26d:	68 65 61 64 65       	push   $0x65646165
 272:	72 5f                	jb     2d3 <.debug_str+0x2d3>
 274:	74 61                	je     2d7 <.debug_str+0x2d7>
 276:	62 6c 65 00          	bound  %ebp,0x0(%ebp,%eiz,2)
 27a:	73 74                	jae    2f0 <.debug_str+0x2f0>
 27c:	72 74                	jb     2f2 <.debug_str+0x2f2>
 27e:	61                   	popa   
 27f:	62 00                	bound  %eax,(%eax)
 281:	5f                   	pop    %edi
 282:	5a                   	pop    %edx
 283:	4e                   	dec    %esi
 284:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 288:	6d                   	insl   (%dx),%es:(%edi)
 289:	69 6e 61 6c 38 6b 70 	imul   $0x706b386c,0x61(%esi),%ebp
 290:	72 69                	jb     2fb <.debug_str+0x2fb>
 292:	6e                   	outsb  %ds:(%esi),(%dx)
 293:	74 66                	je     2fb <.debug_str+0x2fb>
 295:	5f                   	pop    %edi
 296:	45                   	inc    %ebp
 297:	50                   	push   %eax
 298:	4b                   	dec    %ebx
 299:	63 50 63             	arpl   %dx,0x63(%eax)
 29c:	00 6c 6f 6e          	add    %ch,0x6e(%edi,%ebp,2)
 2a0:	67 20 75 6e          	and    %dh,0x6e(%di)
 2a4:	73 69                	jae    30f <.debug_str+0x30f>
 2a6:	67 6e                	outsb  %ds:(%si),(%dx)
 2a8:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 2ad:	74 00                	je     2af <.debug_str+0x2af>
 2af:	73 79                	jae    32a <.debug_str+0x32a>
 2b1:	6d                   	insl   (%dx),%es:(%edi)
 2b2:	74 61                	je     315 <.debug_str+0x315>
 2b4:	62 73 7a             	bound  %esi,0x7a(%ebx)
 2b7:	00 6e 61             	add    %ch,0x61(%esi)
 2ba:	6d                   	insl   (%dx),%es:(%edi)
 2bb:	65 00 77 69          	add    %dh,%gs:0x69(%edi)
 2bf:	64                   	fs
 2c0:	74 68                	je     32a <.debug_str+0x32a>
 2c2:	00 73 69             	add    %dh,0x69(%ebx)
 2c5:	7a 65                	jp     32c <.debug_str+0x32c>
 2c7:	00 73 68             	add    %dh,0x68(%ebx)
 2ca:	6f                   	outsl  %ds:(%esi),(%dx)
 2cb:	72 74                	jb     341 <.debug_str+0x341>
 2cd:	20 75 6e             	and    %dh,0x6e(%ebp)
 2d0:	73 69                	jae    33b <.debug_str+0x33b>
 2d2:	67 6e                	outsb  %ds:(%si),(%dx)
 2d4:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 2d9:	74 00                	je     2db <.debug_str+0x2db>
 2db:	6b 70 75 74          	imul   $0x74,0x75(%eax),%esi
 2df:	73 00                	jae    2e1 <.debug_str+0x2e1>
 2e1:	6b 70 72 69          	imul   $0x69,0x72(%eax),%esi
 2e5:	6e                   	outsb  %ds:(%esi),(%dx)
 2e6:	74 66                	je     34e <.debug_str+0x34e>
 2e8:	5f                   	pop    %edi
 2e9:	00 43 4f             	add    %al,0x4f(%ebx)
 2ec:	4c                   	dec    %esp
 2ed:	4f                   	dec    %edi
 2ee:	52                   	push   %edx
 2ef:	5f                   	pop    %edi
 2f0:	43                   	inc    %ebx
 2f1:	59                   	pop    %ecx
 2f2:	41                   	inc    %ecx
 2f3:	4e                   	dec    %esi
 2f4:	00 62 6f             	add    %ah,0x6f(%edx)
 2f7:	6f                   	outsl  %ds:(%esi),(%dx)
 2f8:	6c                   	insb   (%dx),%es:(%edi)
 2f9:	00 63 6f             	add    %ah,0x6f(%ebx)
 2fc:	6c                   	insb   (%dx),%es:(%edi)
 2fd:	6f                   	outsl  %ds:(%esi),(%dx)
 2fe:	72 00                	jb     300 <.debug_str+0x300>
 300:	73 74                	jae    376 <.debug_str+0x376>
 302:	72 63                	jb     367 <.debug_str+0x367>
 304:	6d                   	insl   (%dx),%es:(%edi)
 305:	70 00                	jo     307 <.debug_str+0x307>
 307:	47                   	inc    %edi
 308:	4e                   	dec    %esi
 309:	55                   	push   %ebp
 30a:	20 43 2b             	and    %al,0x2b(%ebx)
 30d:	2b 20                	sub    (%eax),%esp
 30f:	34 2e                	xor    $0x2e,%al
 311:	39 2e                	cmp    %ebp,(%esi)
 313:	32 20                	xor    (%eax),%ah
 315:	2d 6d 74 75 6e       	sub    $0x6e75746d,%eax
 31a:	65                   	gs
 31b:	3d 67 65 6e 65       	cmp    $0x656e6567,%eax
 320:	72 69                	jb     38b <.debug_str+0x38b>
 322:	63 20                	arpl   %sp,(%eax)
 324:	2d 6d 61 72 63       	sub    $0x6372616d,%eax
 329:	68 3d 70 65 6e       	push   $0x6e65703d
 32e:	74 69                	je     399 <.debug_str+0x399>
 330:	75 6d                	jne    39f <.debug_str+0x39f>
 332:	70 72                	jo     3a6 <.debug_str+0x3a6>
 334:	6f                   	outsl  %ds:(%esi),(%dx)
 335:	20 2d 67 20 2d 4f    	and    %ch,0x4f2d2067
 33b:	32 20                	xor    (%eax),%ah
 33d:	2d 66 66 72 65       	sub    $0x65726666,%eax
 342:	65                   	gs
 343:	73 74                	jae    3b9 <.debug_str+0x3b9>
 345:	61                   	popa   
 346:	6e                   	outsb  %ds:(%esi),(%dx)
 347:	64 69 6e 67 20 2d 66 	imul   $0x6e662d20,%fs:0x67(%esi),%ebp
 34e:	6e 
 34f:	6f                   	outsl  %ds:(%esi),(%dx)
 350:	2d 65 78 63 65       	sub    $0x65637865,%eax
 355:	70 74                	jo     3cb <.debug_str+0x3cb>
 357:	69 6f 6e 73 20 2d 66 	imul   $0x662d2073,0x6e(%edi),%ebp
 35e:	6e                   	outsb  %ds:(%esi),(%dx)
 35f:	6f                   	outsl  %ds:(%esi),(%dx)
 360:	2d 72 74 74 69       	sub    $0x69747472,%eax
 365:	00 31                	add    %dh,(%ecx)
 367:	32 65 6c             	xor    0x6c(%ebp),%ah
 36a:	66 5f                	pop    %di
 36c:	73 79                	jae    3e7 <.debug_str+0x3e7>
 36e:	6d                   	insl   (%dx),%es:(%edi)
 36f:	62 6f 6c             	bound  %ebp,0x6c(%edi)
 372:	5f                   	pop    %edi
 373:	74 00                	je     375 <.debug_str+0x375>
 375:	43                   	inc    %ebx
 376:	4f                   	dec    %edi
 377:	4c                   	dec    %esp
 378:	4f                   	dec    %edi
 379:	52                   	push   %edx
 37a:	5f                   	pop    %edi
 37b:	42                   	inc    %edx
 37c:	4c                   	dec    %esp
 37d:	55                   	push   %ebp
 37e:	45                   	inc    %ebp
 37f:	00 73 69             	add    %dh,0x69(%ebx)
 382:	7a 65                	jp     3e9 <.debug_str+0x3e9>
 384:	74 79                	je     3ff <.debug_str+0x3ff>
 386:	70 65                	jo     3ed <.debug_str+0x3ed>
 388:	00 6d 75             	add    %ch,0x75(%ebp)
 38b:	6c                   	insb   (%dx),%es:(%edi)
 38c:	74 69                	je     3f7 <.debug_str+0x3f7>
 38e:	62 6f 6f             	bound  %ebp,0x6f(%edi)
 391:	74 5f                	je     3f2 <.debug_str+0x3f2>
 393:	65                   	gs
 394:	6c                   	insb   (%dx),%es:(%edi)
 395:	66 5f                	pop    %di
 397:	73 65                	jae    3fe <.debug_str+0x3fe>
 399:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
 39d:	6e                   	outsb  %ds:(%esi),(%dx)
 39e:	5f                   	pop    %edi
 39f:	68 65 61 64 65       	push   $0x65646165
 3a4:	72 5f                	jb     405 <.debug_str+0x405>
 3a6:	74 61                	je     409 <.debug_str+0x409>
 3a8:	62 6c 65 5f          	bound  %ebp,0x5f(%ebp,%eiz,2)
 3ac:	74 00                	je     3ae <.debug_str+0x3ae>
 3ae:	6d                   	insl   (%dx),%es:(%edi)
 3af:	61                   	popa   
 3b0:	6b 65 43 6f          	imul   $0x6f,0x43(%ebp),%esp
 3b4:	6c                   	insb   (%dx),%es:(%edi)
 3b5:	6f                   	outsl  %ds:(%esi),(%dx)
 3b6:	72 00                	jb     3b8 <.debug_str+0x3b8>
 3b8:	5f                   	pop    %edi
 3b9:	5f                   	pop    %edi
 3ba:	67 6e                	outsb  %ds:(%si),(%dx)
 3bc:	75 63                	jne    421 <.debug_str+0x421>
 3be:	5f                   	pop    %edi
 3bf:	76 61                	jbe    422 <.debug_str+0x422>
 3c1:	5f                   	pop    %edi
 3c2:	6c                   	insb   (%dx),%es:(%edi)
 3c3:	69 73 74 00 5f 5a 36 	imul   $0x365a5f00,0x74(%ebx),%esi
 3ca:	73 74                	jae    440 <.debug_str+0x440>
 3cc:	72 63                	jb     431 <.debug_str+0x431>
 3ce:	6d                   	insl   (%dx),%es:(%edi)
 3cf:	70 50                	jo     421 <.debug_str+0x421>
 3d1:	4b                   	dec    %ebx
 3d2:	63 53 30             	arpl   %dx,0x30(%ebx)
 3d5:	5f                   	pop    %edi
 3d6:	00 5f 5a             	add    %bl,0x5a(%edi)
 3d9:	31 36                	xor    %esi,(%esi)
 3db:	65                   	gs
 3dc:	6c                   	insb   (%dx),%es:(%edi)
 3dd:	66 5f                	pop    %di
 3df:	6c                   	insb   (%dx),%es:(%edi)
 3e0:	6f                   	outsl  %ds:(%esi),(%dx)
 3e1:	6f                   	outsl  %ds:(%esi),(%dx)
 3e2:	6b 75 70 53          	imul   $0x53,0x70(%ebp),%esi
 3e6:	79 6d                	jns    455 <.debug_str+0x455>
 3e8:	62 6f 6c             	bound  %ebp,0x6c(%edi)
 3eb:	6d                   	insl   (%dx),%es:(%edi)
 3ec:	00 65 6c             	add    %ah,0x6c(%ebp)
 3ef:	66 5f                	pop    %di
 3f1:	70 72                	jo     465 <.debug_str+0x465>
 3f3:	69 6e 74 53 74 61 63 	imul   $0x63617453,0x74(%esi),%ebp
 3fa:	6b 54 72 61 63       	imul   $0x63,0x61(%edx,%esi,2),%edx
 3ff:	65 00 65 6c          	add    %ah,%gs:0x6c(%ebp)
 403:	66 5f                	pop    %di
 405:	69 6e 69 74 00 5f 5a 	imul   $0x5a5f0074,0x69(%esi),%ebp
 40c:	4e                   	dec    %esi
 40d:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 411:	6d                   	insl   (%dx),%es:(%edi)
 412:	69 6e 61 6c 38 76 67 	imul   $0x6776386c,0x61(%esi),%ebp
 419:	61                   	popa   
 41a:	65 6e                	outsb  %gs:(%esi),(%dx)
 41c:	74 72                	je     490 <.debug_str+0x490>
 41e:	79 45                	jns    465 <.debug_str+0x465>
 420:	63 68 00             	arpl   %bp,0x0(%eax)
 423:	74 61                	je     486 <.debug_str+0x486>
 425:	62 53 69             	bound  %edx,0x69(%ebx)
 428:	7a 65                	jp     48f <.debug_str+0x48f>
 42a:	00 35 65 6c 66 5f    	add    %dh,0x5f666c65
 430:	74 00                	je     432 <.debug_str+0x432>
 432:	49                   	dec    %ecx
 433:	6e                   	outsb  %ds:(%esi),(%dx)
 434:	69 74 00 6d 75 6c 74 	imul   $0x69746c75,0x6d(%eax,%eax,1),%esi
 43b:	69 
 43c:	62 6f 6f             	bound  %ebp,0x6f(%edi)
 43f:	74 5f                	je     4a0 <.debug_str+0x4a0>
 441:	75 69                	jne    4ac <.debug_str+0x4ac>
 443:	6e                   	outsb  %ds:(%esi),(%dx)
 444:	74 33                	je     479 <.debug_str+0x479>
 446:	32 5f 74             	xor    0x74(%edi),%bl
 449:	00 70 72             	add    %dh,0x72(%eax)
 44c:	69 6e 74 42 6f 6f 6c 	imul   $0x6c6f6f42,0x74(%esi),%ebp
 453:	00 5f 5a             	add    %bl,0x5a(%edi)
 456:	4e                   	dec    %esi
 457:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 45b:	6d                   	insl   (%dx),%es:(%edi)
 45c:	69 6e 61 6c 31 30 66 	imul   $0x6630316c,0x61(%esi),%ebp
 463:	61                   	popa   
 464:	74 61                	je     4c7 <.debug_str+0x4c7>
 466:	6c                   	insb   (%dx),%es:(%edi)
 467:	45                   	inc    %ebp
 468:	72 72                	jb     4dc <.debug_str+0x4dc>
 46a:	6f                   	outsl  %ds:(%esi),(%dx)
 46b:	72 45                	jb     4b2 <.debug_str+0x4b2>
 46d:	50                   	push   %eax
 46e:	4b                   	dec    %ebx
 46f:	63 00                	arpl   %ax,(%eax)
 471:	6b 70 72 69          	imul   $0x69,0x72(%eax),%esi
 475:	6e                   	outsb  %ds:(%esi),(%dx)
 476:	74 66                	je     4de <.debug_str+0x4de>
 478:	00 5f 5a             	add    %bl,0x5a(%edi)
 47b:	4e                   	dec    %esi
 47c:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 480:	6d                   	insl   (%dx),%es:(%edi)
 481:	69 6e 61 6c 37 6b 70 	imul   $0x706b376c,0x61(%esi),%ebp
 488:	72 69                	jb     4f3 <.debug_str+0x4f3>
 48a:	6e                   	outsb  %ds:(%esi),(%dx)
 48b:	74 66                	je     4f3 <.debug_str+0x4f3>
 48d:	45                   	inc    %ebp
 48e:	50                   	push   %eax
 48f:	4b                   	dec    %ebx
 490:	63 7a 00             	arpl   %di,0x0(%edx)
 493:	65                   	gs
 494:	6c                   	insb   (%dx),%es:(%edi)
 495:	66 5f                	pop    %di
 497:	6c                   	insb   (%dx),%es:(%edi)
 498:	6f                   	outsl  %ds:(%esi),(%dx)
 499:	6f                   	outsl  %ds:(%esi),(%dx)
 49a:	6b 75 70 53          	imul   $0x53,0x70(%ebp),%esi
 49e:	79 6d                	jns    50d <.debug_str+0x50d>
 4a0:	62 6f 6c             	bound  %ebp,0x6c(%edi)
 4a3:	00 43 4f             	add    %al,0x4f(%ebx)
 4a6:	4c                   	dec    %esp
 4a7:	4f                   	dec    %edi
 4a8:	52                   	push   %edx
 4a9:	5f                   	pop    %edi
 4aa:	42                   	inc    %edx
 4ab:	4c                   	dec    %esp
 4ac:	41                   	inc    %ecx
 4ad:	43                   	inc    %ebx
 4ae:	4b                   	dec    %ebx
 4af:	00 75 6e             	add    %dh,0x6e(%ebp)
 4b2:	73 69                	jae    51d <.debug_str+0x51d>
 4b4:	67 6e                	outsb  %ds:(%si),(%dx)
 4b6:	65 64 20 63 68       	gs and %ah,%fs:%gs:0x68(%ebx)
 4bb:	61                   	popa   
 4bc:	72 00                	jb     4be <.debug_str+0x4be>
 4be:	5f                   	pop    %edi
 4bf:	5a                   	pop    %edx
 4c0:	4e                   	dec    %esi
 4c1:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 4c5:	6d                   	insl   (%dx),%es:(%edi)
 4c6:	69 6e 61 6c 31 30 70 	imul   $0x7030316c,0x61(%esi),%ebp
 4cd:	75 74                	jne    543 <.debug_str+0x543>
 4cf:	65 6e                	outsb  %gs:(%esi),(%dx)
 4d1:	74 72                	je     545 <.debug_str+0x545>
 4d3:	79 61                	jns    536 <.debug_str+0x536>
 4d5:	74 45                	je     51c <.debug_str+0x51c>
 4d7:	63 68 6d             	arpl   %bp,0x6d(%eax)
 4da:	6d                   	insl   (%dx),%es:(%edi)
 4db:	00 68 65             	add    %ch,0x65(%eax)
 4de:	69 67 68 74 00 73 68 	imul   $0x68730074,0x68(%edi),%esp
 4e5:	6f                   	outsl  %ds:(%esi),(%dx)
 4e6:	72 74                	jb     55c <.debug_str+0x55c>
 4e8:	20 69 6e             	and    %ch,0x6e(%ecx)
 4eb:	74 00                	je     4ed <.debug_str+0x4ed>
 4ed:	69 6e 66 6f 00 65 6c 	imul   $0x6c65006f,0x66(%esi),%ebp
 4f4:	66 5f                	pop    %di
 4f6:	73 65                	jae    55d <.debug_str+0x55d>
 4f8:	63 74 69 6f          	arpl   %si,0x6f(%ecx,%ebp,2)
 4fc:	6e                   	outsb  %ds:(%esi),(%dx)
 4fd:	48                   	dec    %eax
 4fe:	65                   	gs
 4ff:	61                   	popa   
 500:	64                   	fs
 501:	65                   	gs
 502:	72 5f                	jb     563 <.debug_str+0x563>
 504:	74 00                	je     506 <.debug_str+0x506>
 506:	5f                   	pop    %edi
 507:	5a                   	pop    %edx
 508:	4e                   	dec    %esi
 509:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 50d:	6d                   	insl   (%dx),%es:(%edi)
 50e:	69 6e 61 6c 34 49 6e 	imul   $0x6e49346c,0x61(%esi),%ebp
 515:	69 74 45 76 00 61 64 	imul   $0x64646100,0x76(%ebp,%eax,2),%esi
 51c:	64 
 51d:	72 61                	jb     580 <.debug_str+0x580>
 51f:	6c                   	insb   (%dx),%es:(%edi)
 520:	69 67 6e 00 43 4f 4c 	imul   $0x4c4f4300,0x6e(%edi),%esp
 527:	4f                   	dec    %edi
 528:	52                   	push   %edx
 529:	5f                   	pop    %edi
 52a:	4c                   	dec    %esp
 52b:	49                   	dec    %ecx
 52c:	47                   	inc    %edi
 52d:	48                   	dec    %eax
 52e:	54                   	push   %esp
 52f:	5f                   	pop    %edi
 530:	47                   	inc    %edi
 531:	52                   	push   %edx
 532:	45                   	inc    %ebp
 533:	45                   	inc    %ebp
 534:	4e                   	dec    %esi
 535:	00 66 69             	add    %ah,0x69(%esi)
 538:	6c                   	insb   (%dx),%es:(%edi)
 539:	6c                   	insb   (%dx),%es:(%edi)
 53a:	00 73 74             	add    %dh,0x74(%ebx)
 53d:	72 74                	jb     5b3 <.debug_str+0x5b3>
 53f:	61                   	popa   
 540:	62 73 7a             	bound  %esi,0x7a(%ebx)
 543:	00 43 4f             	add    %al,0x4f(%ebx)
 546:	4c                   	dec    %esp
 547:	4f                   	dec    %edi
 548:	52                   	push   %edx
 549:	5f                   	pop    %edi
 54a:	47                   	inc    %edi
 54b:	52                   	push   %edx
 54c:	45                   	inc    %ebp
 54d:	45                   	inc    %ebp
 54e:	4e                   	dec    %esi
 54f:	00 75 69             	add    %dh,0x69(%ebp)
 552:	6e                   	outsb  %ds:(%esi),(%dx)
 553:	74 33                	je     588 <.debug_str+0x588>
 555:	32 5f 74             	xor    0x74(%edi),%bl
 558:	00 72 65             	add    %dh,0x65(%edx)
 55b:	73 65                	jae    5c2 <.debug_str+0x5c2>
 55d:	74 43                	je     5a2 <.debug_str+0x5a2>
 55f:	6f                   	outsl  %ds:(%esi),(%dx)
 560:	6c                   	insb   (%dx),%es:(%edi)
 561:	6f                   	outsl  %ds:(%esi),(%dx)
 562:	72 00                	jb     564 <.debug_str+0x564>
 564:	63 68 61             	arpl   %bp,0x61(%eax)
 567:	72 00                	jb     569 <.debug_str+0x569>
 569:	70 75                	jo     5e0 <.debug_str+0x5e0>
 56b:	74 65                	je     5d2 <.debug_str+0x5d2>
 56d:	6e                   	outsb  %ds:(%esi),(%dx)
 56e:	74 72                	je     5e2 <.debug_str+0x5e2>
 570:	79 61                	jns    5d3 <.debug_str+0x5d3>
 572:	74 00                	je     574 <.debug_str+0x574>
 574:	73 72                	jae    5e8 <.debug_str+0x5e8>
 576:	63 2f                	arpl   %bp,(%edi)
 578:	6d                   	insl   (%dx),%es:(%edi)
 579:	6f                   	outsl  %ds:(%esi),(%dx)
 57a:	64                   	fs
 57b:	75 6c                	jne    5e9 <.debug_str+0x5e9>
 57d:	65                   	gs
 57e:	73 2f                	jae    5af <.debug_str+0x5af>
 580:	45                   	inc    %ebp
 581:	6c                   	insb   (%dx),%es:(%edi)
 582:	66                   	data16
 583:	2e 63 70 70          	arpl   %si,%cs:0x70(%eax)
 587:	00 5f 5a             	add    %bl,0x5a(%edi)
 58a:	4e                   	dec    %esi
 58b:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 58f:	6d                   	insl   (%dx),%es:(%edi)
 590:	69 6e 61 6c 39 6d 61 	imul   $0x616d396c,0x61(%esi),%ebp
 597:	6b 65 43 6f          	imul   $0x6f,0x43(%ebp),%esp
 59b:	6c                   	insb   (%dx),%es:(%edi)
 59c:	6f                   	outsl  %ds:(%esi),(%dx)
 59d:	72 45                	jb     5e4 <.debug_str+0x5e4>
 59f:	4e                   	dec    %esi
 5a0:	53                   	push   %ebx
 5a1:	5f                   	pop    %edi
 5a2:	39 76 67             	cmp    %esi,0x67(%esi)
 5a5:	61                   	popa   
 5a6:	5f                   	pop    %edi
 5a7:	63 6f 6c             	arpl   %bp,0x6c(%edi)
 5aa:	6f                   	outsl  %ds:(%esi),(%dx)
 5ab:	72 45                	jb     5f2 <.debug_str+0x5f2>
 5ad:	53                   	push   %ebx
 5ae:	30 5f 00             	xor    %bl,0x0(%edi)
 5b1:	62 75 66             	bound  %esi,0x66(%ebp)
 5b4:	66                   	data16
 5b5:	65                   	gs
 5b6:	72 00                	jb     5b8 <.debug_str+0x5b8>
 5b8:	5f                   	pop    %edi
 5b9:	5a                   	pop    %edx
 5ba:	4e                   	dec    %esi
 5bb:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 5bf:	6d                   	insl   (%dx),%es:(%edi)
 5c0:	69 6e 61 6c 35 6b 70 	imul   $0x706b356c,0x61(%esi),%ebp
 5c7:	75 74                	jne    63d <.debug_str+0x63d>
 5c9:	73 45                	jae    610 <.debug_str+0x610>
 5cb:	50                   	push   %eax
 5cc:	4b                   	dec    %ebx
 5cd:	63 00                	arpl   %ax,(%eax)
 5cf:	5f                   	pop    %edi
 5d0:	5a                   	pop    %edx
 5d1:	4e                   	dec    %esi
 5d2:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 5d6:	6d                   	insl   (%dx),%es:(%edi)
 5d7:	69 6e 61 6c 39 70 72 	imul   $0x7270396c,0x61(%esi),%ebp
 5de:	69 6e 74 42 6f 6f 6c 	imul   $0x6c6f6f42,0x74(%esi),%ebp
 5e5:	45                   	inc    %ebp
 5e6:	62 00                	bound  %eax,(%eax)
 5e8:	6f                   	outsl  %ds:(%esi),(%dx)
 5e9:	66                   	data16
 5ea:	66                   	data16
 5eb:	73 65                	jae    652 <.debug_str+0x652>
 5ed:	74 00                	je     5ef <.debug_str+0x5ef>
 5ef:	63 6f 6c             	arpl   %bp,0x6c(%edi)
 5f2:	75 6d                	jne    661 <.debug_str+0x661>
 5f4:	6e                   	outsb  %ds:(%esi),(%dx)
 5f5:	00 43 4f             	add    %al,0x4f(%ebx)
 5f8:	4c                   	dec    %esp
 5f9:	4f                   	dec    %edi
 5fa:	52                   	push   %edx
 5fb:	5f                   	pop    %edi
 5fc:	4c                   	dec    %esp
 5fd:	49                   	dec    %ecx
 5fe:	47                   	inc    %edi
 5ff:	48                   	dec    %eax
 600:	54                   	push   %esp
 601:	5f                   	pop    %edi
 602:	43                   	inc    %ebx
 603:	59                   	pop    %ecx
 604:	41                   	inc    %ecx
 605:	4e                   	dec    %esi
 606:	00 75 69             	add    %dh,0x69(%ebp)
 609:	6e                   	outsb  %ds:(%esi),(%dx)
 60a:	74 38                	je     644 <.debug_str+0x644>
 60c:	5f                   	pop    %edi
 60d:	74 00                	je     60f <.debug_str+0x60f>
 60f:	5f                   	pop    %edi
 610:	5a                   	pop    %edx
 611:	4e                   	dec    %esi
 612:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 616:	6d                   	insl   (%dx),%es:(%edi)
 617:	69 6e 61 6c 34 66 69 	imul   $0x6966346c,0x61(%esi),%ebp
 61e:	6c                   	insb   (%dx),%es:(%edi)
 61f:	6c                   	insb   (%dx),%es:(%edi)
 620:	45                   	inc    %ebp
 621:	76 00                	jbe    623 <.debug_str+0x623>
 623:	66                   	data16
 624:	6c                   	insb   (%dx),%es:(%edi)
 625:	61                   	popa   
 626:	67 73 00             	addr16 jae 629 <.debug_str+0x629>
 629:	5f                   	pop    %edi
 62a:	5a                   	pop    %edx
 62b:	4e                   	dec    %esi
 62c:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 630:	6d                   	insl   (%dx),%es:(%edi)
 631:	69 6e 61 6c 38 73 65 	imul   $0x6573386c,0x61(%esi),%ebp
 638:	74 43                	je     67d <.debug_str+0x67d>
 63a:	6f                   	outsl  %ds:(%esi),(%dx)
 63b:	6c                   	insb   (%dx),%es:(%edi)
 63c:	6f                   	outsl  %ds:(%esi),(%dx)
 63d:	72 45                	jb     684 <.debug_str+0x684>
 63f:	68 00 5f 5a 4e       	push   $0x4e5a5f00
 644:	38 54 65 72          	cmp    %dl,0x72(%ebp,%eiz,2)
 648:	6d                   	insl   (%dx),%es:(%edi)
 649:	69 6e 61 6c 36 6b 70 	imul   $0x706b366c,0x61(%esi),%ebp
 650:	75 74                	jne    6c6 <_Z19elf_printStackTracev+0x5b6>
 652:	73 5f                	jae    6b3 <_Z19elf_printStackTracev+0x5a3>
 654:	45                   	inc    %ebp
 655:	50                   	push   %eax
 656:	4b                   	dec    %ebx
 657:	63 00                	arpl   %ax,(%eax)
 659:	67                   	addr16
 65a:	65                   	gs
 65b:	74 5f                	je     6bc <_Z19elf_printStackTracev+0x5ac>
 65d:	65 62 70 00          	bound  %esi,%gs:0x0(%eax)
 661:	68 65 61 64 65       	push   $0x65646165
 666:	72 00                	jb     668 <.debug_str+0x668>
 668:	43                   	inc    %ebx
 669:	4f                   	dec    %edi
 66a:	4c                   	dec    %esp
 66b:	4f                   	dec    %edi
 66c:	52                   	push   %edx
 66d:	5f                   	pop    %edi
 66e:	4c                   	dec    %esp
 66f:	49                   	dec    %ecx
 670:	47                   	inc    %edi
 671:	48                   	dec    %eax
 672:	54                   	push   %esp
 673:	5f                   	pop    %edi
 674:	42                   	inc    %edx
 675:	4c                   	dec    %esp
 676:	55                   	push   %ebp
 677:	45                   	inc    %ebp
 678:	00 76 67             	add    %dh,0x67(%esi)
 67b:	61                   	popa   
 67c:	65 6e                	outsb  %gs:(%esi),(%dx)
 67e:	74 72                	je     6f2 <_Z19elf_printStackTracev+0x5e2>
 680:	79 00                	jns    682 <.debug_str+0x682>
 682:	73 68                	jae    6ec <_Z19elf_printStackTracev+0x5dc>
 684:	73 74                	jae    6fa <_Z19elf_printStackTracev+0x5ea>
 686:	72 74                	jb     6fc <_Z19elf_printStackTracev+0x5ec>
 688:	61                   	popa   
 689:	62 00                	bound  %eax,(%eax)
 68b:	76 67                	jbe    6f4 <_Z19elf_printStackTracev+0x5e4>
 68d:	61                   	popa   
 68e:	5f                   	pop    %edi
 68f:	63 6f 6c             	arpl   %bp,0x6c(%edi)
 692:	6f                   	outsl  %ds:(%esi),(%dx)
 693:	72 00                	jb     695 <.debug_str+0x695>
 695:	66 61                	popaw  
 697:	74 61                	je     6fa <_Z19elf_printStackTracev+0x5ea>
 699:	6c                   	insb   (%dx),%es:(%edi)
 69a:	45                   	inc    %ebp
 69b:	72 72                	jb     70f <_Z19elf_printStackTracev+0x5ff>
 69d:	6f                   	outsl  %ds:(%esi),(%dx)
 69e:	72 00                	jb     6a0 <_Z19elf_printStackTracev+0x590>

Disassembly of section .comment:

00000000 <.comment>:
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   0:	00 47 43             	add    %al,0x43(%edi)
   3:	43                   	inc    %ebx
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;

	for(uint32_t i = 0; i < header->num; i++) {
   4:	3a 20                	cmp    (%eax),%ah
#include "libc/String.hpp"
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
   6:	28 47 4e             	sub    %al,0x4e(%edi)
   9:	55                   	push   %ebp
   a:	29 20                	sub    %esp,(%eax)
   c:	34 2e                	xor    $0x2e,%al
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);

	uint32_t shstrtab = sh[header->shndx].addr;
   e:	39 2e                	cmp    %ebp,(%esi)
#include "kernel/KernelGlobals.hpp"

elf_t elf;

void elf_init(multiboot_elf_section_header_table_t* header) {
	elf_sectionHeader_t* sh = reinterpret_cast<elf_sectionHeader_t*>(header-> addr);
  10:	32 00                	xor    (%eax),%al

Disassembly of section .eh_frame:

00000000 <.eh_frame>:
   0:	14 00                	adc    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	00 00                	add    %al,(%eax)
   6:	00 00                	add    %al,(%eax)
   8:	01 7a 52             	add    %edi,0x52(%edx)
   b:	00 01                	add    %al,(%ecx)
   d:	7c 08                	jl     17 <.eh_frame+0x17>
   f:	01 1b                	add    %ebx,(%ebx)
  11:	0c 04                	or     $0x4,%al
  13:	04 88                	add    $0x88,%al
  15:	01 00                	add    %eax,(%eax)
  17:	00 50 00             	add    %dl,0x0(%eax)
  1a:	00 00                	add    %al,(%eax)
  1c:	1c 00                	sbb    $0x0,%al
  1e:	00 00                	add    %al,(%eax)
  20:	00 00                	add    %al,(%eax)
  22:	00 00                	add    %al,(%eax)
  24:	a8 00                	test   $0x0,%al
  26:	00 00                	add    %al,(%eax)
  28:	00 41 0e             	add    %al,0xe(%ecx)
  2b:	08 85 02 41 0e 0c    	or     %al,0xc0e4102(%ebp)
  31:	87 03                	xchg   %eax,(%ebx)
  33:	41                   	inc    %ecx
  34:	0e                   	push   %cs
  35:	10 86 04 41 0e 14    	adc    %al,0x140e4104(%esi)
  3b:	83 05 45 0e 30 02 4a 	addl   $0x4a,0x2300e45
  42:	0e                   	push   %cs
  43:	38 45 0e             	cmp    %al,0xe(%ebp)
  46:	3c 41                	cmp    $0x41,%al
  48:	0e                   	push   %cs
  49:	40                   	inc    %eax
  4a:	48                   	dec    %eax
  4b:	0e                   	push   %cs
  4c:	30 47 0e             	xor    %al,0xe(%edi)
  4f:	38 45 0e             	cmp    %al,0xe(%ebp)
  52:	3c 41                	cmp    $0x41,%al
  54:	0e                   	push   %cs
  55:	40                   	inc    %eax
  56:	48                   	dec    %eax
  57:	0e                   	push   %cs
  58:	30 6d 0e             	xor    %ch,0xe(%ebp)
  5b:	14 41                	adc    $0x41,%al
  5d:	c3                   	ret    
  5e:	0e                   	push   %cs
  5f:	10 41 c6             	adc    %al,-0x3a(%ecx)
  62:	0e                   	push   %cs
  63:	0c 41                	or     $0x41,%al
  65:	c7                   	(bad)  
  66:	0e                   	push   %cs
  67:	08 41 c5             	or     %al,-0x3b(%ecx)
  6a:	0e                   	push   %cs
  6b:	04 20                	add    $0x20,%al
  6d:	00 00                	add    %al,(%eax)
  6f:	00 70 00             	add    %dh,0x0(%eax)
  72:	00 00                	add    %al,(%eax)
  74:	b0 00                	mov    $0x0,%al
  76:	00 00                	add    %al,(%eax)
  78:	54                   	push   %esp
  79:	00 00                	add    %al,(%eax)
  7b:	00 00                	add    %al,(%eax)
  7d:	47                   	inc    %edi
  7e:	0e                   	push   %cs
  7f:	08 83 02 02 43 0a    	or     %al,0xa430202(%ebx)
  85:	c3                   	ret    
  86:	0e                   	push   %cs
  87:	04 46                	add    $0x46,%al
  89:	0b 43 c3             	or     -0x3d(%ebx),%eax
  8c:	0e                   	push   %cs
  8d:	04 00                	add    $0x0,%al
  8f:	00 6c 00 00          	add    %ch,0x0(%eax,%eax,1)
  93:	00 94 00 00 00 10 01 	add    %dl,0x1100000(%eax,%eax,1)
  9a:	00 00                	add    %al,(%eax)
  9c:	97                   	xchg   %eax,%edi
  9d:	00 00                	add    %al,(%eax)
  9f:	00 00                	add    %al,(%eax)
  a1:	41                   	inc    %ecx
  a2:	0e                   	push   %cs
  a3:	08 86 02 41 0e 0c    	or     %al,0xc0e4102(%esi)
  a9:	83 03 43             	addl   $0x43,(%ebx)
  ac:	0e                   	push   %cs
  ad:	10 48 0e             	adc    %cl,0xe(%eax)
  b0:	14 42                	adc    $0x42,%al
  b2:	0e                   	push   %cs
  b3:	18 47 0e             	sbb    %al,0xe(%edi)
  b6:	1c 45                	sbb    $0x45,%al
  b8:	0e                   	push   %cs
  b9:	20 48 0e             	and    %cl,0xe(%eax)
  bc:	14 45                	adc    $0x45,%al
  be:	0e                   	push   %cs
  bf:	18 45 0e             	sbb    %al,0xe(%ebp)
  c2:	1c 45                	sbb    $0x45,%al
  c4:	0e                   	push   %cs
  c5:	20 48 0e             	and    %cl,0xe(%eax)
  c8:	10 49 0e             	adc    %cl,0xe(%ecx)
  cb:	14 42                	adc    $0x42,%al
  cd:	0e                   	push   %cs
  ce:	18 45 0e             	sbb    %al,0xe(%ebp)
  d1:	1c 45                	sbb    $0x45,%al
  d3:	0e                   	push   %cs
  d4:	20 48 0e             	and    %cl,0xe(%eax)
  d7:	14 43                	adc    $0x43,%al
  d9:	0e                   	push   %cs
  da:	18 45 0e             	sbb    %al,0xe(%ebp)
  dd:	1c 45                	sbb    $0x45,%al
  df:	0e                   	push   %cs
  e0:	20 53 0e             	and    %dl,0xe(%ebx)
  e3:	10 41 0e             	adc    %al,0xe(%ecx)
  e6:	14 41                	adc    $0x41,%al
  e8:	0e                   	push   %cs
  e9:	18 45 0e             	sbb    %al,0xe(%ebp)
  ec:	1c 45                	sbb    $0x45,%al
  ee:	0e                   	push   %cs
  ef:	20 4a 0e             	and    %cl,0xe(%edx)
  f2:	10 47 0e             	adc    %al,0xe(%edi)
  f5:	0c 41                	or     $0x41,%al
  f7:	c3                   	ret    
  f8:	0e                   	push   %cs
  f9:	08 41 c6             	or     %al,-0x3a(%ecx)
  fc:	0e                   	push   %cs
  fd:	04 00                	add    $0x0,%al
	...
